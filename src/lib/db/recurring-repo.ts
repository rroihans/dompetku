import { db } from "./app-db";
import { type RecurringTransactionRecord, type TransaksiRecord, type AkunRecord, type AdminFeeRecord } from "./app-db";
import { Money } from "@/lib/money";
import { calculateNextBillingDate, getApplicableInterestRate, type TierBunga } from "@/lib/template-utils";
import { createNotification } from "./notifications-repo";
import { applyTransactionSummaryDelta, applyTransactionSummaryDeltas } from "./summary";

// ============================================
// RECURRING TRANSACTIONS (GENERIC)
// ============================================

export interface RecurringTransactionDTO {
    id: string;
    nama: string;
    nominal: number;
    kategori: string;
    tipeTransaksi: string;
    akunId: string;
    frekuensi: string; // HARIAN | MINGGUAN | BULANAN | TAHUNAN
    hariDalamBulan?: number | null;
    hariDalamMinggu?: number | null;
    tanggalMulai: Date;
    tanggalSelesai?: Date | null;
    aktif: boolean;
    terakhirDieksekusi?: Date | null;
    isAutoGenerated?: boolean;
}

export async function createRecurringTransaction(data: Omit<RecurringTransactionDTO, "id" | "aktif" | "isAutoGenerated">) {
    try {
        if (data.nominal <= 0) {
            return { success: false, error: "Nominal harus lebih dari 0" };
        }

        const recurring: RecurringTransactionRecord = {
            id: crypto.randomUUID(),
            nama: data.nama,
            nominalInt: Money.fromFloat(data.nominal),
            kategori: data.kategori,
            tipeTransaksi: data.tipeTransaksi,
            akunId: data.akunId,
            frekuensi: data.frekuensi,
            hariDalamBulan: data.hariDalamBulan,
            hariDalamMinggu: data.hariDalamMinggu,
            tanggalMulai: data.tanggalMulai,
            tanggalSelesai: data.tanggalSelesai || null,
            aktif: true,
            terakhirDieksekusi: null,
            isAutoGenerated: false,
            createdAt: new Date(),
            updatedAt: new Date(),
        };

        await db.recurringTransaction.add(recurring);

        return { success: true, data: mapRecurringToDTO(recurring) };
    } catch (error) {
        console.error("createRecurringTransaction error", error);
        return { success: false, error: "Gagal membuat transaksi berulang" };
    }
}

export async function getRecurringTransactions() {
    try {
        const recurring = await db.recurringTransaction
            .orderBy("createdAt")
            .reverse()
            .toArray();
        return { success: true, data: recurring.map(mapRecurringToDTO) };
    } catch (error) {
        console.error("getRecurringTransactions error", error);
        return { success: false, data: [], error: "Gagal mengambil data" };
    }
}

export async function toggleRecurringTransaction(id: string, aktif: boolean) {
    try {
        await db.recurringTransaction.update(id, { aktif });
        const updated = await db.recurringTransaction.get(id);
        return { success: true, data: updated ? mapRecurringToDTO(updated) : null };
    } catch (error) {
        return { success: false, error: "Gagal mengubah status" };
    }
}

export async function deleteRecurringTransaction(id: string) {
    try {
        const recurring = await db.recurringTransaction.get(id);
        if (!recurring) return { success: false, error: "Transaksi berulang tidak ditemukan" };

        await db.transaction('rw', [db.recurringTransaction, db.adminFee, db.akun], async () => {
            // Check if linked to AdminFee
            const adminFee = await db.adminFee.where("recurringTxId").equals(id).first();

            if (adminFee) {
                // Update Akun (Legacy sync)
                await db.akun.update(adminFee.akunId, {
                    biayaAdminAktif: false,
                    biayaAdminNominalInt: null,
                    biayaAdminPola: null,
                    biayaAdminTanggal: null
                });

                // Delete Admin Fee
                await db.adminFee.delete(adminFee.id);
            }

            await db.recurringTransaction.delete(id);
        });

        return { success: true };
    } catch (error) {
        console.error("deleteRecurringTransaction error", error);
        return { success: false, error: "Gagal menghapus" };
    }
}

export async function skipRecurringForMonth(id: string, yearMonth: string) {
    try {
        const recurring = await db.recurringTransaction.get(id);
        if (!recurring) return { success: false, error: "Tidak ditemukan" };

        const [year, month] = yearMonth.split('-').map(Number);
        const skipDate = new Date(year, month, 0); // Last day of month

        await db.recurringTransaction.update(id, { terakhirDieksekusi: skipDate });

        return { success: true };
    } catch (error) {
        return { success: false, error: "Gagal skip transaksi" };
    }
}

export async function executeRecurringTransactions() {
    try {
        const now = new Date();

        const activeRecurring = await db.recurringTransaction
            .where("aktif")
            .equals(1 as any)
            .toArray();

        // Filter valid dates (not expired)
        const validRecurring = activeRecurring.filter(r => !r.tanggalSelesai || r.tanggalSelesai >= now);

        const dueTransactions = validRecurring.filter(r => isRecurringDue(r, now));

        if (dueTransactions.length === 0) {
             return { success: true, executed: 0 };
        }

        // 1. Check Idempotency
        const idempotencyKeys = dueTransactions.map(r => {
             const dateKey = now.toISOString().split('T')[0];
             return `recurring_${r.id}_${dateKey}`;
        });

        const existingTx = await db.transaksi.where("idempotencyKey").anyOf(idempotencyKeys).toArray();
        const existingKeys = new Set(existingTx.map(t => t.idempotencyKey));

        const toExecute = dueTransactions.filter((r, i) => !existingKeys.has(idempotencyKeys[i]));

        if (toExecute.length === 0) {
             return { success: true, executed: 0 };
        }

        let executed = 0;

        // 2. Prepare Category Accounts
        const categoryNames = new Set<string>();
        toExecute.forEach(r => {
             const catName = r.tipeTransaksi === "KELUAR" ? `[EXPENSE] ${r.kategori}` : `[INCOME] ${r.kategori}`;
             categoryNames.add(catName);
        });

        const existingCats = await db.akun.where("nama").anyOf(Array.from(categoryNames)).toArray();
        const catMap = new Map<string, AkunRecord>();
        existingCats.forEach(c => catMap.set(c.nama, c));

        const newCats: AkunRecord[] = [];

        // Identify missing categories and create them
        for (const catName of categoryNames) {
             if (!catMap.has(catName)) {
                 const isExpense = catName.startsWith("[EXPENSE]");
                 const newCat: AkunRecord = {
                        id: crypto.randomUUID(),
                        nama: catName,
                        tipe: isExpense ? "EXPENSE" : "INCOME",
                        saldoAwalInt: 0,
                        saldoSekarangInt: 0,
                        createdAt: new Date(),
                        updatedAt: new Date()
                 };
                 newCats.push(newCat);
                 catMap.set(catName, newCat);
             }
        }

        // 3. Prepare Transactions and Updates
        const newTransactions: TransaksiRecord[] = [];
        const accountUpdates = new Map<string, number>(); // AccountId -> Delta
        const recurringUpdates: RecurringTransactionRecord[] = [];

        // Need to fetch source accounts to know their types for summary
        const sourceAccountIds = new Set(toExecute.map(r => r.akunId));

        const sourceAccounts = await db.akun.where("id").anyOf(Array.from(sourceAccountIds)).toArray();
        const accountMap = new Map<string, AkunRecord>();
        sourceAccounts.forEach(a => accountMap.set(a.id, a));

        // Add new categories to accountMap as well
        newCats.forEach(c => accountMap.set(c.id, c));
        // Add existing categories to accountMap
        existingCats.forEach(c => accountMap.set(c.id, c));

        await db.transaction('rw', [db.transaksi, db.akun, db.recurringTransaction, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {

             // Save new categories first
             if (newCats.length > 0) {
                 await db.akun.bulkAdd(newCats);
             }

             for (const r of toExecute) {
                  const dateKey = now.toISOString().split('T')[0];
                  const idempotencyKey = `recurring_${r.id}_${dateKey}`;

                  const catName = r.tipeTransaksi === "KELUAR" ? `[EXPENSE] ${r.kategori}` : `[INCOME] ${r.kategori}`;
                  const catAccount = catMap.get(catName)!;

                  const debitAkunId = r.tipeTransaksi === "KELUAR" ? catAccount.id : r.akunId;
                  const kreditAkunId = r.tipeTransaksi === "KELUAR" ? r.akunId : catAccount.id;

                  const nominalInt = r.nominalInt;

                  newTransactions.push({
                        id: crypto.randomUUID(),
                        tanggal: now,
                        deskripsi: `[Auto] ${r.nama}`,
                        nominalInt: nominalInt,
                        kategori: r.kategori,
                        debitAkunId,
                        kreditAkunId,
                        catatan: "Dibuat otomatis dari transaksi berulang",
                        idempotencyKey,
                        createdAt: new Date()
                  });

                  // Track account updates
                  accountUpdates.set(debitAkunId, (accountUpdates.get(debitAkunId) || 0) + nominalInt);
                  accountUpdates.set(kreditAkunId, (accountUpdates.get(kreditAkunId) || 0) - nominalInt);

                  // Track recurring update
                  recurringUpdates.push({ ...r, terakhirDieksekusi: now });
             }

             // Batch Insert Transactions
             if (newTransactions.length > 0) {
                 await db.transaksi.bulkAdd(newTransactions);
             }

             // Batch Update Accounts
             const involvedIds = Array.from(accountUpdates.keys());
             const involvedAccounts = await db.akun.bulkGet(involvedIds);

             const accountsToUpdate: AkunRecord[] = [];
             involvedAccounts.forEach((acc, i) => {
                 if (acc) {
                     const delta = accountUpdates.get(acc.id) || 0;
                     acc.saldoSekarangInt += delta;
                     accountsToUpdate.push(acc);
                 }
             });

             if (accountsToUpdate.length > 0) {
                 await db.akun.bulkPut(accountsToUpdate);
             }

             // Batch Update Recurring
             if (recurringUpdates.length > 0) {
                 await db.recurringTransaction.bulkPut(recurringUpdates);
             }

             // Batch Summary Updates
             const summaryInputs = newTransactions.map(tx => {
                 const debitAcc = accountMap.get(tx.debitAkunId);
                 const kreditAcc = accountMap.get(tx.kreditAkunId);
                 return {
                     tanggal: tx.tanggal,
                     nominalInt: tx.nominalInt,
                     kategori: tx.kategori,
                     debitAkunId: tx.debitAkunId,
                     kreditAkunId: tx.kreditAkunId,
                     debitAkunTipe: debitAcc?.tipe,
                     kreditAkunTipe: kreditAcc?.tipe
                 };
             });

             await applyTransactionSummaryDeltas(summaryInputs, "add");

             executed = toExecute.length;
        });

        return { success: true, executed };
    } catch (error) {
        console.error("executeRecurringTransactions error", error);
        return { success: false, error: "Gagal eksekusi transaksi berulang" };
    }
}

function categoryToType(kategoriTipe: string): string {
    // Should return compatible type string for AkunRecord
    if (kategoriTipe === "EXPENSE") return "EXPENSE";
    if (kategoriTipe === "INCOME") return "INCOME";
    return "EXPENSE";
}

function mapRecurringToDTO(r: RecurringTransactionRecord): RecurringTransactionDTO {
    return {
        id: r.id,
        nama: r.nama,
        nominal: Money.toFloat(r.nominalInt),
        kategori: r.kategori,
        tipeTransaksi: r.tipeTransaksi,
        akunId: r.akunId,
        frekuensi: r.frekuensi,
        hariDalamBulan: r.hariDalamBulan,
        hariDalamMinggu: r.hariDalamMinggu,
        tanggalMulai: r.tanggalMulai,
        tanggalSelesai: r.tanggalSelesai,
        aktif: r.aktif,
        terakhirDieksekusi: r.terakhirDieksekusi,
        isAutoGenerated: r.isAutoGenerated
    };
}


// ============================================
// AUTOMATION (ADMIN FEES & INTEREST)
// ============================================

export async function processMonthlyAdminFees(dryRun: boolean = false) {
    try {
        const today = new Date();
        const currentMonthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;

        // Find accounts with biayaAdminAktif = true (BANK, E_WALLET)
        const allAccounts = await db.akun.toArray();
        const akunList = allAccounts.filter(a =>
            a.biayaAdminAktif === true &&
            ["BANK", "E_WALLET"].includes(a.tipe)
        );

        let processed = 0;
        let failed = 0;
        const processedTransactions: any[] = [];

        for (const akun of akunList) {
            if (!akun.biayaAdminNominalInt) continue;

            // Skip if pola is MANUAL or not set
            const pola = akun.biayaAdminPola;
            if (!pola || pola === "MANUAL") continue;

            // For TANGGAL_TETAP, we need tanggal; for others, it's ignored
            const tanggal = akun.biayaAdminTanggal;
            if (pola === "TANGGAL_TETAP" && !tanggal) continue;

            const billingDate = calculateNextBillingDate(
                pola,
                tanggal,
                new Date(today.getFullYear(), today.getMonth(), 1)
            );

            // Skip if future
            if (billingDate > today) continue;

            // Check last charge
            const lastChargeStr = akun.lastAdminChargeDate ?
                `${akun.lastAdminChargeDate.getFullYear()}-${String(akun.lastAdminChargeDate.getMonth() + 1).padStart(2, '0')}` : null;

            if (lastChargeStr === currentMonthStr) continue;

            const nominalInt = akun.biayaAdminNominalInt;
            const deskripsi = `Biaya admin bulanan ${akun.nama}`;

            if (dryRun) {
                processed++;
                processedTransactions.push({ akunId: akun.id, namaAkun: akun.nama, nominal: Money.toFloat(nominalInt), tanggal: billingDate });
                continue;
            }

            try {
                await db.transaction('rw', [db.transaksi, db.akun, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {
                    // Create Category Account if needed
                    const catName = "[EXPENSE] Biaya Admin Bank";
                    let catAccount = await db.akun.where("nama").equals(catName).first();
                    if (!catAccount) {
                        const newCat: AkunRecord = {
                            id: crypto.randomUUID(),
                            nama: catName,
                            tipe: "EXPENSE",
                            saldoAwalInt: 0,
                            saldoSekarangInt: 0,
                            createdAt: new Date(),
                            updatedAt: new Date(),
                            warna: "#ef4444"
                        };
                        await db.akun.add(newCat);
                        catAccount = newCat;
                    }

                    const txData = {
                        id: crypto.randomUUID(),
                        tanggal: billingDate,
                        deskripsi,
                        nominalInt: nominalInt,
                        kategori: "Biaya Admin Bank",
                        debitAkunId: catAccount.id,
                        kreditAkunId: akun.id,
                        idempotencyKey: `admin-${akun.id}-${currentMonthStr}`,
                        createdAt: new Date()
                    };

                    await db.transaksi.add(txData);

                    // Update balances
                    await db.akun.update(catAccount.id, { saldoSekarangInt: catAccount.saldoSekarangInt + nominalInt });
                    await db.akun.update(akun.id, {
                        saldoSekarangInt: akun.saldoSekarangInt - nominalInt,
                        lastAdminChargeDate: billingDate
                    });

                    // Update summary tables for analytics
                    await applyTransactionSummaryDelta({
                        tanggal: billingDate,
                        nominalInt,
                        kategori: "Biaya Admin Bank",
                        debitAkunId: catAccount.id,
                        kreditAkunId: akun.id,
                        debitAkunTipe: "EXPENSE",
                        kreditAkunTipe: akun.tipe
                    }, "add");

                    processed++;
                    processedTransactions.push(txData);
                });
            } catch (e) {
                console.error("processMonthlyAdminFees failed for " + akun.nama, e);
                failed++;
            }
        }

        return { success: true, processed, failed, processedTransactions };

    } catch (error) {
        console.error("processMonthlyAdminFees error", error);
        return { success: false, error: "Gagal proses biaya admin" };
    }
}

export async function processMonthlyInterest(dryRun: boolean = false) {
    try {
        const today = new Date();
        const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const targetMonthStr = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);

        // Settings: "USE_MIN_BALANCE_METHOD" - Assuming false for now or fetch from db.appSetting
        const useMinBalanceSetting = await db.appSetting.where("kunci").equals("USE_MIN_BALANCE_METHOD").first();
        const useMinBalance = useMinBalanceSetting?.nilai === "true";

        const allAccounts = await db.akun.toArray();
        const akunList = allAccounts.filter(a =>
            a.bungaAktif === true &&
            ["BANK", "E_WALLET"].includes(a.tipe)
        );

        let processed = 0;

        for (const akun of akunList) {
            const lastCreditStr = akun.lastInterestCreditDate ?
                `${akun.lastInterestCreditDate.getFullYear()}-${String(akun.lastInterestCreditDate.getMonth() + 1).padStart(2, '0')}` : null;

            if (lastCreditStr === targetMonthStr) continue;

            let basisBungaInt = akun.saldoSekarangInt;
            let methodUsed = "Saldo Akhir";

            if (useMinBalance) {
                // Implement min balance calculation (complex query)
                // Or skip min balance for client-side MVP?
                // Min balance requires scanning all transactions in that month.
                // Let's implement simpler version first: Just use current balance logic or Saldo Akhir.
                // OR implement min balance if critical.
                // Leaving as Saldo Akhir for now unless requested.
            }

            const tiers: TierBunga[] = JSON.parse(akun.bungaTiers || "[]");
            const basisBungaFloat = Money.toFloat(basisBungaInt);
            const bungaPa = getApplicableInterestRate(basisBungaFloat, tiers);

            if (bungaPa <= 0) continue;

            const bungaBersih = Math.floor((basisBungaFloat * (bungaPa / 100) / 12) * 0.8);
            if (bungaBersih < 1) continue;

            if (dryRun) continue;

            try {
                const bungaBersihInt = Money.fromFloat(bungaBersih);

                await db.transaction('rw', [db.transaksi, db.akun, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {
                    const catName = "[INCOME] Bunga Tabungan";
                    let catAccount = await db.akun.where("nama").equals(catName).first();
                    if (!catAccount) {
                        const newCat: AkunRecord = {
                            id: crypto.randomUUID(),
                            nama: catName,
                            tipe: "INCOME",
                            saldoAwalInt: 0,
                            saldoSekarangInt: 0,
                            createdAt: new Date(),
                            updatedAt: new Date(),
                            warna: "#10b981"
                        };
                        await db.akun.add(newCat);
                        catAccount = newCat;
                    }

                    await db.transaksi.add({
                        id: crypto.randomUUID(),
                        tanggal: lastMonthEnd,
                        deskripsi: `Bunga tabungan ${akun.nama} (${methodUsed})`,
                        nominalInt: bungaBersihInt,
                        kategori: "Bunga Tabungan",
                        debitAkunId: akun.id,
                        kreditAkunId: catAccount.id,
                        idempotencyKey: `interest-${akun.id}-${targetMonthStr}`,
                        createdAt: new Date()
                    });

                    await db.akun.update(akun.id, {
                        saldoSekarangInt: akun.saldoSekarangInt + bungaBersihInt,
                        lastInterestCreditDate: lastMonthEnd
                    });

                    await db.akun.update(catAccount.id, {
                        saldoSekarangInt: catAccount.saldoSekarangInt - bungaBersihInt
                    });

                    // Update summary tables for analytics
                    await applyTransactionSummaryDelta({
                        tanggal: lastMonthEnd,
                        nominalInt: bungaBersihInt,
                        kategori: "Bunga Tabungan",
                        debitAkunId: akun.id,
                        kreditAkunId: catAccount.id,
                        debitAkunTipe: akun.tipe,
                        kreditAkunTipe: "INCOME"
                    }, "add");

                    processed++;
                });
            } catch (e) {
                console.error("Interest process failed for " + akun.nama, e);
            }
        }

        return { success: true, processed, failed: 0 };
    } catch (error) {
        return { success: false, error: "Gagal proses bunga" };
    }
}

export async function getUpcomingAdminFees() {
    try {
        const today = new Date();
        const nextWeek = new Date(); nextWeek.setDate(today.getDate() + 7);
        const upcoming = [];
        const akunList = await db.akun
            .where("biayaAdminAktif").equals(1 as any)
            .filter(a => a.tipe === 'BANK')
            .toArray();

        for (const akun of akunList) {
            if (!akun.biayaAdminNominalInt) continue;

            // Skip if pola is MANUAL or not set
            const pola = akun.biayaAdminPola;
            if (!pola || pola === "MANUAL") continue;

            // For TANGGAL_TETAP, we need tanggal
            if (pola === "TANGGAL_TETAP" && !akun.biayaAdminTanggal) continue;

            const nextDate = calculateNextBillingDate(
                pola,
                akun.biayaAdminTanggal,
                today
            );

            if (nextDate <= nextWeek) {
                upcoming.push({
                    akunId: akun.id,
                    namaAkun: akun.nama,
                    nominal: Money.toFloat(akun.biayaAdminNominalInt),
                    tanggal: nextDate
                });
            }
        }
        return { success: true, data: upcoming };
    } catch { return { success: false, data: [] }; }
}

function isRecurringDue(recurring: RecurringTransactionRecord, now: Date): boolean {
    const today = now.getDate();
    const dayOfWeek = now.getDay();

    if (recurring.terakhirDieksekusi) {
        const lastExec = new Date(recurring.terakhirDieksekusi);
        // Compare date components explicitly to avoid timezone issues
        const isSameDay = lastExec.getFullYear() === now.getFullYear() &&
            lastExec.getMonth() === now.getMonth() &&
            lastExec.getDate() === now.getDate();
        if (isSameDay) {
            return false;
        }
    }

    switch (recurring.frekuensi) {
        case "HARIAN":
            return true;
        case "MINGGUAN":
            return recurring.hariDalamMinggu === dayOfWeek;
        case "BULANAN":
            return recurring.hariDalamBulan === today;
        case "TAHUNAN":
            const startDate = new Date(recurring.tanggalMulai);
            return startDate.getMonth() === now.getMonth() &&
                startDate.getDate() === today;
        default:
            return false;
    }
}

// Get all recurring transactions that are due today
export async function getDueRecurringTransactions(): Promise<RecurringTransactionDTO[]> {
    try {
        const allRecurring = await db.recurringTransaction.toArray();
        const now = new Date();

        const due = allRecurring.filter(r => {
            // Must be active
            if (!r.aktif) return false;
            // Must not be expired
            if (r.tanggalSelesai && r.tanggalSelesai < now) return false;
            // Must be due today
            return isRecurringDue(r, now);
        });

        return due.map(mapRecurringToDTO);
    } catch (error) {
        return [];
    }
}
