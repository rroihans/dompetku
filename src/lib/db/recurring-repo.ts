import { db } from "./app-db";
import { type RecurringTransactionRecord, type TransaksiRecord, type AkunRecord, type AdminFeeRecord } from "./app-db";
import { Money } from "@/lib/money";
import { calculateNextBillingDate, getApplicableInterestRate, type TierBunga } from "@/lib/template-utils";
import { createNotification } from "./notifications-repo";
import { applyTransactionSummaryDelta } from "./summary";

// ============================================
// RECURRING TRANSACTIONS (GENERIC)
// ============================================

export interface RecurringTransactionDTO {
    id: string;
    nama: string;
    nominal: number;
    kategori: string;
    tipeTransaksi: string;
    akunId: string;
    frekuensi: string; // HARIAN | MINGGUAN | BULANAN | TAHUNAN
    hariDalamBulan?: number | null;
    hariDalamMinggu?: number | null;
    tanggalMulai: Date;
    tanggalSelesai?: Date | null;
    aktif: boolean;
    terakhirDieksekusi?: Date | null;
    isAutoGenerated?: boolean;
}

export async function createRecurringTransaction(data: Omit<RecurringTransactionDTO, "id" | "aktif" | "isAutoGenerated">) {
    try {
        if (data.nominal <= 0) {
            return { success: false, error: "Nominal harus lebih dari 0" };
        }

        const recurring: RecurringTransactionRecord = {
            id: crypto.randomUUID(),
            nama: data.nama,
            nominalInt: Money.fromFloat(data.nominal),
            kategori: data.kategori,
            tipeTransaksi: data.tipeTransaksi,
            akunId: data.akunId,
            frekuensi: data.frekuensi,
            hariDalamBulan: data.hariDalamBulan,
            hariDalamMinggu: data.hariDalamMinggu,
            tanggalMulai: data.tanggalMulai,
            tanggalSelesai: data.tanggalSelesai || null,
            aktif: true,
            terakhirDieksekusi: null,
            isAutoGenerated: false,
            createdAt: new Date(),
            updatedAt: new Date(),
        };

        await db.recurringTransaction.add(recurring);

        return { success: true, data: mapRecurringToDTO(recurring) };
    } catch (error) {
        console.error("createRecurringTransaction error", error);
        return { success: false, error: "Gagal membuat transaksi berulang" };
    }
}

export async function getRecurringTransactions() {
    try {
        const recurring = await db.recurringTransaction
            .orderBy("createdAt")
            .reverse()
            .toArray();
        return { success: true, data: recurring.map(mapRecurringToDTO) };
    } catch (error) {
        console.error("getRecurringTransactions error", error);
        return { success: false, data: [], error: "Gagal mengambil data" };
    }
}

export async function toggleRecurringTransaction(id: string, aktif: boolean) {
    try {
        await db.recurringTransaction.update(id, { aktif });
        const updated = await db.recurringTransaction.get(id);
        return { success: true, data: updated ? mapRecurringToDTO(updated) : null };
    } catch (error) {
        return { success: false, error: "Gagal mengubah status" };
    }
}

export async function deleteRecurringTransaction(id: string) {
    try {
        const recurring = await db.recurringTransaction.get(id);
        if (!recurring) return { success: false, error: "Transaksi berulang tidak ditemukan" };

        await db.transaction('rw', [db.recurringTransaction, db.adminFee, db.akun], async () => {
            // Check if linked to AdminFee
            const adminFee = await db.adminFee.where("recurringTxId").equals(id).first();

            if (adminFee) {
                // Update Akun (Legacy sync)
                await db.akun.update(adminFee.akunId, {
                    biayaAdminAktif: false,
                    biayaAdminNominalInt: null,
                    biayaAdminPola: null,
                    biayaAdminTanggal: null
                });

                // Delete Admin Fee
                await db.adminFee.delete(adminFee.id);
            }

            await db.recurringTransaction.delete(id);
        });

        return { success: true };
    } catch (error) {
        console.error("deleteRecurringTransaction error", error);
        return { success: false, error: "Gagal menghapus" };
    }
}

export async function skipRecurringForMonth(id: string, yearMonth: string) {
    try {
        const recurring = await db.recurringTransaction.get(id);
        if (!recurring) return { success: false, error: "Tidak ditemukan" };

        const [year, month] = yearMonth.split('-').map(Number);
        const skipDate = new Date(year, month, 0); // Last day of month

        await db.recurringTransaction.update(id, { terakhirDieksekusi: skipDate });

        return { success: true };
    } catch (error) {
        return { success: false, error: "Gagal skip transaksi" };
    }
}

export async function executeRecurringTransactions() {
    try {
        const now = new Date();
        const today = now.getDate();
        const dayOfWeek = now.getDay(); // 0 = Minggu

        const activeRecurring = await db.recurringTransaction
            .where("aktif")
            .equals(1 as any)
            .toArray();

        // Filter valid dates (not expired)
        const validRecurring = activeRecurring.filter(r => !r.tanggalSelesai || r.tanggalSelesai >= now);

        let executed = 0;

        for (const recurring of validRecurring) {
            if (isRecurringDue(recurring, now)) {
                const dateKey = now.toISOString().split('T')[0];
                const idempotencyKey = `recurring_${recurring.id}_${dateKey}`;

                // Idempotency check 
                const existing = await db.transaksi.where("idempotencyKey").equals(idempotencyKey).first();
                if (existing) continue;

                // Create Transaction
                const kategoriTipe = recurring.tipeTransaksi === "KELUAR" ? "EXPENSE" : "INCOME";

                // Find/Create Category Account
                const catName = recurring.tipeTransaksi === "KELUAR" ? `[EXPENSE] ${recurring.kategori}` : `[INCOME] ${recurring.kategori}`;
                let catAccount = await db.akun.where("nama").equals(catName).first();

                if (!catAccount) {
                    // Create minimal Category Account
                    const newCat: AkunRecord = {
                        id: crypto.randomUUID(),
                        nama: catName,
                        tipe: categoryToType(kategoriTipe), // Helper needs to map 'EXPENSE' -> 'PENGELUARAN'?? app-db.ts says 'EXPENSE' type is string.
                        // app-db.ts: tipe: // BANK | E_WALLET | CASH | CREDIT_CARD | EXPENSE | INCOME
                        // So literal "EXPENSE" or "INCOME"
                        saldoAwalInt: 0,
                        saldoSekarangInt: 0,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    // But wait, category account type is purely a convention here? 
                    // app-db.ts says tipe is string.
                    // Let's assume valid types are capitalized "EXPENSE", "INCOME".

                    if (recurring.tipeTransaksi === "KELUAR") newCat.tipe = "EXPENSE";
                    else newCat.tipe = "INCOME";

                    await db.akun.add(newCat);
                    catAccount = newCat;
                }

                const debitAkunId = recurring.tipeTransaksi === "KELUAR" ? catAccount.id : recurring.akunId;
                const kreditAkunId = recurring.tipeTransaksi === "KELUAR" ? recurring.akunId : catAccount.id;

                await db.transaction('rw', [db.transaksi, db.akun, db.recurringTransaction, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {
                    const nominalInt = recurring.nominalInt;

                    await db.transaksi.add({
                        id: crypto.randomUUID(),
                        tanggal: now,
                        deskripsi: `[Auto] ${recurring.nama}`,
                        nominalInt: nominalInt,
                        kategori: recurring.kategori,
                        debitAkunId,
                        kreditAkunId,
                        catatan: "Dibuat otomatis dari transaksi berulang",
                        idempotencyKey,
                        createdAt: new Date()
                    });

                    // Update balances
                    const debtAcc = await db.akun.get(debitAkunId);
                    const credAcc = await db.akun.get(kreditAkunId);

                    if (debtAcc) await db.akun.update(debitAkunId, { saldoSekarangInt: debtAcc.saldoSekarangInt + nominalInt });
                    if (credAcc) await db.akun.update(kreditAkunId, { saldoSekarangInt: credAcc.saldoSekarangInt - nominalInt });

                    // Update summary tables for analytics
                    await applyTransactionSummaryDelta({
                        tanggal: now,
                        nominalInt,
                        kategori: recurring.kategori,
                        debitAkunId,
                        kreditAkunId,
                        debitAkunTipe: debtAcc?.tipe,
                        kreditAkunTipe: credAcc?.tipe
                    }, "add");

                    // Update recurring status
                    await db.recurringTransaction.update(recurring.id, { terakhirDieksekusi: now });
                });

                executed++;
            }
        }

        return { success: true, executed };
    } catch (error) {
        console.error("executeRecurringTransactions error", error);
        return { success: false, error: "Gagal eksekusi transaksi berulang" };
    }
}

function categoryToType(kategoriTipe: string): string {
    // Should return compatible type string for AkunRecord
    if (kategoriTipe === "EXPENSE") return "EXPENSE";
    if (kategoriTipe === "INCOME") return "INCOME";
    return "EXPENSE";
}

function mapRecurringToDTO(r: RecurringTransactionRecord): RecurringTransactionDTO {
    return {
        id: r.id,
        nama: r.nama,
        nominal: Money.toFloat(r.nominalInt),
        kategori: r.kategori,
        tipeTransaksi: r.tipeTransaksi,
        akunId: r.akunId,
        frekuensi: r.frekuensi,
        hariDalamBulan: r.hariDalamBulan,
        hariDalamMinggu: r.hariDalamMinggu,
        tanggalMulai: r.tanggalMulai,
        tanggalSelesai: r.tanggalSelesai,
        aktif: r.aktif,
        terakhirDieksekusi: r.terakhirDieksekusi,
        isAutoGenerated: r.isAutoGenerated
    };
}


// ============================================
// AUTOMATION (ADMIN FEES & INTEREST)
// ============================================

export async function processMonthlyAdminFees(dryRun: boolean = false) {
    try {
        const today = new Date();
        const currentMonthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;

        // Find accounts with biayaAdminAktif = true (BANK, E_WALLET)
        const allAccounts = await db.akun.toArray();
        const akunList = allAccounts.filter(a =>
            a.biayaAdminAktif === true &&
            ["BANK", "E_WALLET"].includes(a.tipe)
        );

        let processed = 0;
        let failed = 0;
        const processedTransactions: any[] = [];

        for (const akun of akunList) {
            if (!akun.biayaAdminNominalInt) continue;

            // Skip if pola is MANUAL or not set
            const pola = akun.biayaAdminPola;
            if (!pola || pola === "MANUAL") continue;

            // For TANGGAL_TETAP, we need tanggal; for others, it's ignored
            const tanggal = akun.biayaAdminTanggal;
            if (pola === "TANGGAL_TETAP" && !tanggal) continue;

            const billingDate = calculateNextBillingDate(
                pola,
                tanggal,
                new Date(today.getFullYear(), today.getMonth(), 1)
            );

            // Skip if future
            if (billingDate > today) continue;

            // Check last charge
            const lastChargeStr = akun.lastAdminChargeDate ?
                `${akun.lastAdminChargeDate.getFullYear()}-${String(akun.lastAdminChargeDate.getMonth() + 1).padStart(2, '0')}` : null;

            if (lastChargeStr === currentMonthStr) continue;

            const nominalInt = akun.biayaAdminNominalInt;
            const deskripsi = `Biaya admin bulanan ${akun.nama}`;

            if (dryRun) {
                processed++;
                processedTransactions.push({ akunId: akun.id, namaAkun: akun.nama, nominal: Money.toFloat(nominalInt), tanggal: billingDate });
                continue;
            }

            try {
                await db.transaction('rw', [db.transaksi, db.akun, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {
                    // Create Category Account if needed
                    const catName = "[EXPENSE] Biaya Admin Bank";
                    let catAccount = await db.akun.where("nama").equals(catName).first();
                    if (!catAccount) {
                        const newCat: AkunRecord = {
                            id: crypto.randomUUID(),
                            nama: catName,
                            tipe: "EXPENSE",
                            saldoAwalInt: 0,
                            saldoSekarangInt: 0,
                            createdAt: new Date(),
                            updatedAt: new Date(),
                            warna: "#ef4444"
                        };
                        await db.akun.add(newCat);
                        catAccount = newCat;
                    }

                    const txData = {
                        id: crypto.randomUUID(),
                        tanggal: billingDate,
                        deskripsi,
                        nominalInt: nominalInt,
                        kategori: "Biaya Admin Bank",
                        debitAkunId: catAccount.id,
                        kreditAkunId: akun.id,
                        idempotencyKey: `admin-${akun.id}-${currentMonthStr}`,
                        createdAt: new Date()
                    };

                    await db.transaksi.add(txData);

                    // Update balances
                    await db.akun.update(catAccount.id, { saldoSekarangInt: catAccount.saldoSekarangInt + nominalInt });
                    await db.akun.update(akun.id, {
                        saldoSekarangInt: akun.saldoSekarangInt - nominalInt,
                        lastAdminChargeDate: billingDate
                    });

                    // Update summary tables for analytics
                    await applyTransactionSummaryDelta({
                        tanggal: billingDate,
                        nominalInt,
                        kategori: "Biaya Admin Bank",
                        debitAkunId: catAccount.id,
                        kreditAkunId: akun.id,
                        debitAkunTipe: "EXPENSE",
                        kreditAkunTipe: akun.tipe
                    }, "add");

                    processed++;
                    processedTransactions.push(txData);
                });
            } catch (e) {
                console.error("processMonthlyAdminFees failed for " + akun.nama, e);
                failed++;
            }
        }

        return { success: true, processed, failed, processedTransactions };

    } catch (error) {
        console.error("processMonthlyAdminFees error", error);
        return { success: false, error: "Gagal proses biaya admin" };
    }
}

export async function processMonthlyInterest(dryRun: boolean = false) {
    try {
        const today = new Date();
        const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
        const targetMonthStr = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`;
        const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0);

        // Settings: "USE_MIN_BALANCE_METHOD" - Assuming false for now or fetch from db.appSetting
        const useMinBalanceSetting = await db.appSetting.where("kunci").equals("USE_MIN_BALANCE_METHOD").first();
        const useMinBalance = useMinBalanceSetting?.nilai === "true";

        const allAccounts = await db.akun.toArray();
        const akunList = allAccounts.filter(a =>
            a.bungaAktif === true &&
            ["BANK", "E_WALLET"].includes(a.tipe)
        );

        let processed = 0;

        for (const akun of akunList) {
            const lastCreditStr = akun.lastInterestCreditDate ?
                `${akun.lastInterestCreditDate.getFullYear()}-${String(akun.lastInterestCreditDate.getMonth() + 1).padStart(2, '0')}` : null;

            if (lastCreditStr === targetMonthStr) continue;

            let basisBungaInt = akun.saldoSekarangInt;
            let methodUsed = "Saldo Akhir";

            if (useMinBalance) {
                // Implement min balance calculation (complex query)
                // Or skip min balance for client-side MVP?
                // Min balance requires scanning all transactions in that month.
                // Let's implement simpler version first: Just use current balance logic or Saldo Akhir.
                // OR implement min balance if critical.
                // Leaving as Saldo Akhir for now unless requested.
            }

            const tiers: TierBunga[] = JSON.parse(akun.bungaTiers || "[]");
            const basisBungaFloat = Money.toFloat(basisBungaInt);
            const bungaPa = getApplicableInterestRate(basisBungaFloat, tiers);

            if (bungaPa <= 0) continue;

            const bungaBersih = Math.floor((basisBungaFloat * (bungaPa / 100) / 12) * 0.8);
            if (bungaBersih < 1) continue;

            if (dryRun) continue;

            try {
                const bungaBersihInt = Money.fromFloat(bungaBersih);

                await db.transaction('rw', [db.transaksi, db.akun, db.summaryMonth, db.summaryCategoryMonth, db.summaryHeatmapDay, db.summaryAccountMonth], async () => {
                    const catName = "[INCOME] Bunga Tabungan";
                    let catAccount = await db.akun.where("nama").equals(catName).first();
                    if (!catAccount) {
                        const newCat: AkunRecord = {
                            id: crypto.randomUUID(),
                            nama: catName,
                            tipe: "INCOME",
                            saldoAwalInt: 0,
                            saldoSekarangInt: 0,
                            createdAt: new Date(),
                            updatedAt: new Date(),
                            warna: "#10b981"
                        };
                        await db.akun.add(newCat);
                        catAccount = newCat;
                    }

                    await db.transaksi.add({
                        id: crypto.randomUUID(),
                        tanggal: lastMonthEnd,
                        deskripsi: `Bunga tabungan ${akun.nama} (${methodUsed})`,
                        nominalInt: bungaBersihInt,
                        kategori: "Bunga Tabungan",
                        debitAkunId: akun.id,
                        kreditAkunId: catAccount.id,
                        idempotencyKey: `interest-${akun.id}-${targetMonthStr}`,
                        createdAt: new Date()
                    });

                    await db.akun.update(akun.id, {
                        saldoSekarangInt: akun.saldoSekarangInt + bungaBersihInt,
                        lastInterestCreditDate: lastMonthEnd
                    });

                    await db.akun.update(catAccount.id, {
                        saldoSekarangInt: catAccount.saldoSekarangInt - bungaBersihInt
                    });

                    // Update summary tables for analytics
                    await applyTransactionSummaryDelta({
                        tanggal: lastMonthEnd,
                        nominalInt: bungaBersihInt,
                        kategori: "Bunga Tabungan",
                        debitAkunId: akun.id,
                        kreditAkunId: catAccount.id,
                        debitAkunTipe: akun.tipe,
                        kreditAkunTipe: "INCOME"
                    }, "add");

                    processed++;
                });
            } catch (e) {
                console.error("Interest process failed for " + akun.nama, e);
            }
        }

        return { success: true, processed, failed: 0 };
    } catch (error) {
        return { success: false, error: "Gagal proses bunga" };
    }
}

export async function getUpcomingAdminFees() {
    try {
        const today = new Date();
        const nextWeek = new Date(); nextWeek.setDate(today.getDate() + 7);
        const upcoming = [];
        const akunList = await db.akun
            .where("biayaAdminAktif").equals(1 as any)
            .filter(a => a.tipe === 'BANK')
            .toArray();

        for (const akun of akunList) {
            if (!akun.biayaAdminNominalInt) continue;

            // Skip if pola is MANUAL or not set
            const pola = akun.biayaAdminPola;
            if (!pola || pola === "MANUAL") continue;

            // For TANGGAL_TETAP, we need tanggal
            if (pola === "TANGGAL_TETAP" && !akun.biayaAdminTanggal) continue;

            const nextDate = calculateNextBillingDate(
                pola,
                akun.biayaAdminTanggal,
                today
            );

            if (nextDate <= nextWeek) {
                upcoming.push({
                    akunId: akun.id,
                    namaAkun: akun.nama,
                    nominal: Money.toFloat(akun.biayaAdminNominalInt),
                    tanggal: nextDate
                });
            }
        }
        return { success: true, data: upcoming };
    } catch { return { success: false, data: [] }; }
}

function isRecurringDue(recurring: RecurringTransactionRecord, now: Date): boolean {
    const today = now.getDate();
    const dayOfWeek = now.getDay();

    if (recurring.terakhirDieksekusi) {
        const lastExec = new Date(recurring.terakhirDieksekusi);
        // Compare date components explicitly to avoid timezone issues
        const isSameDay = lastExec.getFullYear() === now.getFullYear() &&
            lastExec.getMonth() === now.getMonth() &&
            lastExec.getDate() === now.getDate();
        if (isSameDay) {
            return false;
        }
    }

    switch (recurring.frekuensi) {
        case "HARIAN":
            return true;
        case "MINGGUAN":
            return recurring.hariDalamMinggu === dayOfWeek;
        case "BULANAN":
            return recurring.hariDalamBulan === today;
        case "TAHUNAN":
            const startDate = new Date(recurring.tanggalMulai);
            return startDate.getMonth() === now.getMonth() &&
                startDate.getDate() === today;
        default:
            return false;
    }
}

// Get all recurring transactions that are due today
export async function getDueRecurringTransactions(): Promise<RecurringTransactionDTO[]> {
    try {
        const allRecurring = await db.recurringTransaction.toArray();
        const now = new Date();

        const due = allRecurring.filter(r => {
            // Must be active
            if (!r.aktif) return false;
            // Must not be expired
            if (r.tanggalSelesai && r.tanggalSelesai < now) return false;
            // Must be due today
            return isRecurringDue(r, now);
        });

        return due.map(mapRecurringToDTO);
    } catch (error) {
        return [];
    }
}
