import { db } from "./app-db";
import { type AdminFeeRecord, type RecurringTransactionRecord, type AkunRecord } from "./app-db";
import { Money } from "@/lib/money";

export interface AdminFeeDTO {
    id: string;
    akunId: string;
    deskripsi: string;
    nominal: number;
    recurringTxId?: string | null;
    isActive: boolean;
    recurringTx?: any; // To hold joined data
}

export async function createAdminFee(
    akunId: string,
    deskripsi: string,
    nominal: number
) {
    try {
        if (!akunId || !deskripsi || nominal <= 0) {
            return { success: false, error: "Data tidak valid" };
        }

        const akun = await db.akun.get(akunId);
        if (!akun) {
            return { success: false, error: "Akun tidak ditemukan" };
        }

        const result = await db.transaction('rw', [db.adminFee, db.recurringTransaction, db.akun], async () => {
            const nominalInt = Money.fromFloat(nominal);
            const recurringID = crypto.randomUUID();
            const adminFeeID = crypto.randomUUID();

            // 1. Create recurring transaction
            const recurringTx: RecurringTransactionRecord = {
                id: recurringID,
                nama: `[Auto] ${deskripsi}`,
                nominalInt: nominalInt,
                kategori: "Biaya Admin",
                tipeTransaksi: "KELUAR",
                akunId: akunId,
                frekuensi: "BULANAN",
                hariDalamBulan: 1,
                aktif: true,
                isAutoGenerated: true,
                createdAt: new Date(),
                updatedAt: new Date(),
                tanggalMulai: new Date(),
                terakhirDieksekusi: null
            };
            await db.recurringTransaction.add(recurringTx);

            // 2. Create admin fee
            const adminFee: AdminFeeRecord = {
                id: adminFeeID,
                akunId,
                deskripsi,
                nominal, // Stored as number (Float?) in schema? app-db says number. AdminFee usually uses Money logic but let's check schema.
                // app-db: nominal: number. Using Float here as per DTO usually.
                // Wait, app-db RecurringTransactionRecord uses nominalInt. AdminFeeRecord uses nominal. 
                // Let's stick to Schema. Schema `AdminFeeRecord` has `nominal: number`.
                // Ideally it should be Int, but I must follow schema. 
                recurringTxId: recurringID,
                isActive: true,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            await db.adminFee.add(adminFee);

            return { adminFee, recurringTx };
        });

        return {
            success: true,
            data: result.adminFee,
            message: `Admin fee "${deskripsi}" berhasil dibuat dengan recurring transaction`
        };

    } catch (error) {
        console.error("createAdminFee error", error);
        return { success: false, error: "Gagal membuat admin fee" };
    }
}

export async function updateAdminFee(
    id: string,
    deskripsi: string,
    nominal: number
) {
    try {
        if (!id || !deskripsi || nominal <= 0) {
            return { success: false, error: "Data tidak valid" };
        }

        const existing = await db.adminFee.get(id);
        if (!existing) return { success: false, error: "Admin fee tidak ditemukan" };

        await db.transaction('rw', [db.adminFee, db.recurringTransaction], async () => {
            // 1. Update admin fee
            await db.adminFee.update(id, {
                deskripsi,
                nominal,
                updatedAt: new Date()
            });

            // 2. Update recurring tx
            if (existing.recurringTxId) {
                await db.recurringTransaction.update(existing.recurringTxId, {
                    nama: `[Auto] ${deskripsi}`,
                    nominalInt: Money.fromFloat(nominal),
                    updatedAt: new Date()
                });
            }
        });

        return { success: true, message: "Admin fee berhasil diperbarui" };
    } catch (error) {
        return { success: false, error: "Gagal memperbarui admin fee" };
    }
}

export async function deleteAdminFee(id: string) {
    try {
        const existing = await db.adminFee.get(id);
        if (!existing) return { success: false, error: "Admin fee tidak ditemukan" };

        await db.transaction('rw', [db.adminFee, db.recurringTransaction, db.akun], async () => {
            if (existing.recurringTxId) {
                await db.recurringTransaction.delete(existing.recurringTxId);
            }

            // Legacy sync
            await db.akun.update(existing.akunId, {
                biayaAdminAktif: false,
                biayaAdminNominalInt: null,
                biayaAdminPola: null,
                biayaAdminTanggal: null
            });

            await db.adminFee.delete(id);
        });

        return { success: true, message: "Admin fee berhasil dihapus" };
    } catch (error) {
        return { success: false, error: "Gagal menghapus admin fee" };
    }
}

export async function getAdminFeesByAkun(akunId: string) {
    try {
        const adminFees = await db.adminFee.where("akunId").equals(akunId).toArray();

        // Manual Join for recurringTx
        const data = await Promise.all(adminFees.map(async (fee) => {
            let recurringTx = null;
            if (fee.recurringTxId) {
                recurringTx = await db.recurringTransaction.get(fee.recurringTxId);
            }
            return {
                ...fee,
                recurringTx
            };
        }));

        return { success: true, data };
    } catch (error) {
        return { success: false, data: [], error: "Gagal mengambil admin fees" };
    }
}

export async function toggleAdminFee(id: string, isActive: boolean) {
    try {
        const existing = await db.adminFee.get(id);
        if (!existing) return { success: false, error: "Admin fee tidak ditemukan" };

        await db.transaction('rw', [db.adminFee, db.recurringTransaction], async () => {
            await db.adminFee.update(id, { isActive });

            if (existing.recurringTxId) {
                await db.recurringTransaction.update(existing.recurringTxId, { aktif: isActive });
            }
        });

        return { success: true };
    } catch (error) {
        return { success: false, error: "Gagal mengubah status admin fee" };
    }
}
