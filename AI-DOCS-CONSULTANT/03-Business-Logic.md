# Business Logic & Utilities

# Server Actions (src/app/actions)


## File: src\app\actions\admin-fee.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"

/**
 * Create admin fee with auto-generated recurring transaction
 */
export async function createAdminFee(
    akunId: string,
    deskripsi: string,
    nominal: number
) {
    try {
        // Validate inputs
        if (!akunId || !deskripsi || nominal <= 0) {
            return { success: false, error: "Data tidak valid" }
        }

        // Get account details
        const akun = await prisma.akun.findUnique({
            where: { id: akunId }
        })

        if (!akun) {
            return { success: false, error: "Akun tidak ditemukan" }
        }

        // Use Prisma transaction for atomicity
        const result = await prisma.$transaction(async (tx) => {
            // 1. Create recurring transaction first
            const recurringTx = await tx.recurringTransaction.create({
                data: {
                    nama: `[Auto] ${deskripsi}`,
                    nominal: nominal,
                    kategori: "Biaya Admin",
                    tipeTransaksi: "KELUAR",
                    akunId: akunId,
                    frekuensi: "BULANAN",
                    hariDalamBulan: 1, // Default: tanggal 1
                    aktif: true,
                    isAutoGenerated: true
                }
            })

            // 2. Create admin fee linked to recurring
            const adminFee = await tx.adminFee.create({
                data: {
                    akunId: akunId,
                    deskripsi: deskripsi,
                    nominal: nominal,
                    recurringTxId: recurringTx.id,
                    isActive: true
                }
            })

            return { adminFee, recurringTx }
        })

        await logSistem("INFO", "ADMIN_FEE",
            `Admin fee dibuat: ${deskripsi} (Rp ${nominal.toLocaleString('id-ID')}) untuk ${akun.nama}`)

        revalidatePath("/akun")
        revalidatePath(`/akun/${akunId}`)
        revalidatePath("/recurring")

        return {
            success: true,
            data: result.adminFee,
            message: `Admin fee "${deskripsi}" berhasil dibuat dengan recurring transaction`
        }
    } catch (error) {
        await logSistem("ERROR", "ADMIN_FEE", "Gagal membuat admin fee", (error as Error).stack)
        return { success: false, error: "Gagal membuat admin fee" }
    }
}

/**
 * Update admin fee and its linked recurring transaction
 */
export async function updateAdminFee(
    id: string,
    deskripsi: string,
    nominal: number
) {
    try {
        if (!id || !deskripsi || nominal <= 0) {
            return { success: false, error: "Data tidak valid" }
        }

        // Get existing admin fee
        const existing = await prisma.adminFee.findUnique({
            where: { id },
            include: { recurringTx: true, akun: true }
        })

        if (!existing) {
            return { success: false, error: "Admin fee tidak ditemukan" }
        }

        // Use transaction for atomicity
        await prisma.$transaction(async (tx) => {
            // 1. Update admin fee
            await tx.adminFee.update({
                where: { id },
                data: {
                    deskripsi,
                    nominal,
                    updatedAt: new Date()
                }
            })

            // 2. Update linked recurring transaction if exists
            if (existing.recurringTxId) {
                await tx.recurringTransaction.update({
                    where: { id: existing.recurringTxId },
                    data: {
                        nama: `[Auto] ${deskripsi}`,
                        nominal,
                        updatedAt: new Date()
                    }
                })
            }
        })

        await logSistem("INFO", "ADMIN_FEE",
            `Admin fee diperbarui: ${deskripsi} untuk ${existing.akun.nama}`)

        revalidatePath("/akun")
        revalidatePath(`/akun/${existing.akunId}`)
        revalidatePath("/recurring")

        return { success: true, message: "Admin fee berhasil diperbarui" }
    } catch (error) {
        await logSistem("ERROR", "ADMIN_FEE", "Gagal memperbarui admin fee", (error as Error).stack)
        return { success: false, error: "Gagal memperbarui admin fee" }
    }
}

/**
 * Delete admin fee (cascade deletes recurring transaction)
 */
export async function deleteAdminFee(id: string) {
    try {
        // Get existing admin fee
        const existing = await prisma.adminFee.findUnique({
            where: { id },
            include: { recurringTx: true, akun: true }
        })

        if (!existing) {
            return { success: false, error: "Admin fee tidak ditemukan" }
        }

        // Use transaction for atomicity
        await prisma.$transaction(async (tx) => {
            // 1. Delete recurring transaction first (if exists)
            if (existing.recurringTxId) {
                await tx.recurringTransaction.delete({
                    where: { id: existing.recurringTxId }
                })
            }

            // 2. Delete admin fee
            await tx.adminFee.delete({
                where: { id }
            })
        })

        await logSistem("INFO", "ADMIN_FEE",
            `Admin fee dihapus: ${existing.deskripsi} dari ${existing.akun.nama}`)

        revalidatePath("/akun")
        revalidatePath(`/akun/${existing.akunId}`)
        revalidatePath("/recurring")

        return { success: true, message: "Admin fee berhasil dihapus" }
    } catch (error) {
        await logSistem("ERROR", "ADMIN_FEE", "Gagal menghapus admin fee", (error as Error).stack)
        return { success: false, error: "Gagal menghapus admin fee" }
    }
}

/**
 * Get all admin fees for an account
 */
export async function getAdminFeesByAkun(akunId: string) {
    try {
        const adminFees = await prisma.adminFee.findMany({
            where: { akunId },
            include: {
                recurringTx: true
            },
            orderBy: { createdAt: "desc" }
        })

        return { success: true, data: adminFees }
    } catch (error) {
        await logSistem("ERROR", "ADMIN_FEE", "Gagal mengambil admin fees", (error as Error).stack)
        return { success: false, data: [], error: "Gagal mengambil admin fees" }
    }
}

/**
 * Toggle admin fee active status
 */
export async function toggleAdminFee(id: string, isActive: boolean) {
    try {
        const existing = await prisma.adminFee.findUnique({
            where: { id },
            include: { recurringTx: true, akun: true }
        })

        if (!existing) {
            return { success: false, error: "Admin fee tidak ditemukan" }
        }

        await prisma.$transaction(async (tx) => {
            // Update admin fee status
            await tx.adminFee.update({
                where: { id },
                data: { isActive }
            })

            // Update recurring transaction status
            if (existing.recurringTxId) {
                await tx.recurringTransaction.update({
                    where: { id: existing.recurringTxId },
                    data: { aktif: isActive }
                })
            }
        })

        await logSistem("INFO", "ADMIN_FEE",
            `Admin fee ${isActive ? 'diaktifkan' : 'dinonaktifkan'}: ${existing.deskripsi}`)

        revalidatePath("/akun")
        revalidatePath(`/akun/${existing.akunId}`)
        revalidatePath("/recurring")

        return { success: true }
    } catch (error) {
        await logSistem("ERROR", "ADMIN_FEE", "Gagal toggle admin fee", (error as Error).stack)
        return { success: false, error: "Gagal mengubah status admin fee" }
    }
}

```

## File: src\app\actions\akun.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

// Tipe akun yang ditampilkan ke user (bukan internal)
const USER_ACCOUNT_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

// Untuk pagination
const PAGE_SIZE = 8

// Mendapatkan akun user (bukan akun kategori internal)
export async function getAkunUser(page: number = 1) {
    try {
        const skip = (page - 1) * PAGE_SIZE

        const [akuns, total] = await Promise.all([
            prisma.akun.findMany({
                where: {
                    tipe: { in: USER_ACCOUNT_TYPES }
                },
                orderBy: { createdAt: "desc" },
                skip,
                take: PAGE_SIZE,
            }),
            prisma.akun.count({
                where: {
                    tipe: { in: USER_ACCOUNT_TYPES }
                }
            }),
        ])

        const dataMapped = akuns.map(akun => ({
            ...akun,
            saldoSekarang: Money.toFloat(Number(akun.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(akun.saldoAwal)),
            limitKredit: akun.limitKredit ? Money.toFloat(Number(akun.limitKredit)) : null,
        }))

        return {
            data: dataMapped,
            pagination: {
                page,
                pageSize: PAGE_SIZE,
                total,
                totalPages: Math.ceil(total / PAGE_SIZE),
            },
        }
    } catch (error) {
        await logSistem("ERROR", "AKUN", "Gagal mengambil data akun user", (error as Error).stack)
        throw new Error("Gagal mengambil data akun")
    }
}

// Mendapatkan semua akun (termasuk internal) - untuk dropdown, dll
export async function getAkun() {
    try {
        const akuns = await prisma.akun.findMany({
            where: {
                tipe: { in: USER_ACCOUNT_TYPES }
            },
            orderBy: { createdAt: "desc" },
        })

        return akuns.map(akun => ({
            ...akun,
            saldoSekarang: Money.toFloat(Number(akun.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(akun.saldoAwal)),
            limitKredit: akun.limitKredit ? Money.toFloat(Number(akun.limitKredit)) : null,
        }))
    } catch (error) {
        await logSistem("ERROR", "AKUN", "Gagal mengambil data akun", (error as Error).stack)
        throw new Error("Gagal mengambil data akun")
    }
}

export async function createAkun(data: {
    nama: string
    tipe: string
    saldoAwal: number
    limitKredit?: number
    templateId?: string | null
    templateSource?: string | null
    biayaAdminAktif?: boolean
    biayaAdminNominal?: number | null
    biayaAdminPola?: string | null
    biayaAdminTanggal?: number | null
    bungaAktif?: boolean
    bungaTiers?: string | null
    setoranAwal?: number | null
    icon?: string
    warna?: string
    // Credit Card fields (v0.5.0)
    isSyariah?: boolean | null
    billingDate?: number | null
    dueDate?: number | null
    minPaymentFixed?: number | null
    minPaymentPercent?: number | null
    minInstallmentAmount?: number | null
    useDecimalFormat?: boolean
}) {
    try {
        // Validasi nama unik
        const existingAkun = await prisma.akun.findFirst({
            where: { nama: data.nama }
        })

        if (existingAkun) {
            return { success: false, error: `Akun dengan nama "${data.nama}" sudah ada` }
        }

        const saldoAwalInt = BigInt(Money.fromFloat(data.saldoAwal))
        const limitKreditInt = data.limitKredit ? BigInt(Money.fromFloat(data.limitKredit)) : null
        const setoranAwalInt = data.setoranAwal ? BigInt(Money.fromFloat(data.setoranAwal)) : null
        const minPaymentFixedInt = data.minPaymentFixed ? BigInt(Money.fromFloat(data.minPaymentFixed)) : null
        const minInstallmentAmountInt = data.minInstallmentAmount ? BigInt(Money.fromFloat(data.minInstallmentAmount)) : null

        const akun = await prisma.akun.create({
            data: {
                ...data,
                // Int mappings (Single Source)
                saldoAwal: saldoAwalInt,
                saldoSekarang: saldoAwalInt, // Start same as saldoAwal
                limitKredit: limitKreditInt,
                setoranAwal: setoranAwalInt,
                minPaymentFixed: minPaymentFixedInt,
                minInstallmentAmount: minInstallmentAmountInt,

                settingsLastModified: new Date(),
            },
        })

        await logSistem("INFO", "AKUN", `Akun baru dibuat: ${akun.nama}`)
        revalidatePath("/akun")
        revalidatePath("/")
        
        // Map back to float for return
        const mappedAkun = {
            ...akun,
            saldoSekarang: Money.toFloat(Number(akun.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(akun.saldoAwal)),
            limitKredit: akun.limitKredit ? Money.toFloat(Number(akun.limitKredit)) : null,
        }
        
        return { success: true, data: mappedAkun }
    } catch (error) {
        await logSistem("ERROR", "AKUN", "Gagal membuat akun baru", (error as Error).stack)
        return { success: false, error: "Gagal membuat akun baru" }
    }
}

export async function updateAkun(id: string, data: {
    nama?: string
    tipe?: string
    limitKredit?: number
    templateId?: string | null
    templateSource?: string | null
    biayaAdminAktif?: boolean
    biayaAdminNominal?: number | null
    biayaAdminPola?: string | null
    biayaAdminTanggal?: number | null
    bungaAktif?: boolean
    bungaTiers?: string | null
    templateOverrides?: string | null
    setoranAwal?: number | null
    icon?: string
    warna?: string
    // Credit Card fields (v0.5.0)
    isSyariah?: boolean | null
    billingDate?: number | null
    dueDate?: number | null
    minPaymentFixed?: number | null
    minPaymentPercent?: number | null
    minInstallmentAmount?: number | null
    useDecimalFormat?: boolean
}) {
    try {
        // Validasi nama unik (jika nama berubah)
        if (data.nama) {
            const existingAkun = await prisma.akun.findFirst({
                where: {
                    nama: data.nama,
                    NOT: { id } // Exclude current akun
                }
            })

            if (existingAkun) {
                return { success: false, error: `Akun dengan nama "${data.nama}" sudah ada` }
            }
        }

        const updateData: any = { ...data }

        if (data.biayaAdminAktif !== undefined || data.bungaAktif !== undefined) {
            updateData.settingsLastModified = new Date()
        }

        // Int Mappings
        if (data.limitKredit !== undefined) updateData.limitKredit = data.limitKredit ? BigInt(Money.fromFloat(data.limitKredit)) : null
        if (data.setoranAwal !== undefined) updateData.setoranAwal = data.setoranAwal ? BigInt(Money.fromFloat(data.setoranAwal)) : null
        if (data.minPaymentFixed !== undefined) updateData.minPaymentFixed = data.minPaymentFixed ? BigInt(Money.fromFloat(data.minPaymentFixed)) : null
        if (data.minInstallmentAmount !== undefined) updateData.minInstallmentAmount = data.minInstallmentAmount ? BigInt(Money.fromFloat(data.minInstallmentAmount)) : null


        const akun = await prisma.akun.update({
            where: { id },
            data: updateData,
        })

        await logSistem("INFO", "AKUN", `Akun diperbarui: ${akun.nama}`)
        revalidatePath("/akun")
        revalidatePath(`/akun/${id}`)
        revalidatePath("/")
        
        const mappedAkun = {
            ...akun,
            saldoSekarang: Money.toFloat(Number(akun.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(akun.saldoAwal)),
            limitKredit: akun.limitKredit ? Money.toFloat(Number(akun.limitKredit)) : null,
        }

        return { success: true, data: mappedAkun }
    } catch (error) {
        await logSistem("ERROR", "AKUN", "Gagal memperbarui akun", (error as Error).stack)
        return { success: false, error: "Gagal memperbarui akun" }
    }
}

export async function updateAkunSettings(id: string, settings: {
    biayaAdminAktif: boolean
    biayaAdminNominal: number | null
    biayaAdminPola: string | null
    biayaAdminTanggal: number | null
    bungaAktif: boolean
    bungaTiers: string | null
}) {
    try {
        const currentAkun = await prisma.akun.findUnique({
            where: { id },
            include: { template: true }
        })

        if (!currentAkun) return { success: false, error: "Akun tidak ditemukan" }

        // Track overrides if templateSource exists
        const overrides = currentAkun.templateOverrides ? JSON.parse(currentAkun.templateOverrides) : {}

        // Simple override tracking logic
        const timestamp = new Date().toISOString()
        overrides.history = overrides.history || []
        overrides.history.push({
            timestamp,
            changes: settings
        })

        // Limit history to last 10 changes
        if (overrides.history.length > 10) {
            overrides.history = overrides.history.slice(-10)
        }

        const updated = await prisma.akun.update({
            where: { id },
            data: {
                ...settings,
                templateOverrides: JSON.stringify(overrides),
                settingsLastModified: new Date()
            }
        })

        await logSistem("INFO", "AKUN", `Pengaturan akun "${updated.nama}" diperbarui`)
        revalidatePath(`/akun/${id}`)
        
         const mappedAkun = {
            ...updated,
            saldoSekarang: Money.toFloat(Number(updated.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(updated.saldoAwal)),
            limitKredit: updated.limitKredit ? Money.toFloat(Number(updated.limitKredit)) : null,
        }
        
        return { success: true, data: mappedAkun }
    } catch (error) {
        await logSistem("ERROR", "AKUN", `Gagal memperbarui pengaturan aku
... (truncated)
```

## File: src\app\actions\analytics.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { Money } from "@/lib/money"

// Tipe akun user (bukan internal)
const USER_ACCOUNT_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

interface PengeluaranPerKategori {
    kategori: string
    total: number
    jumlah: number
}

interface TrendBulanan {
    bulan: string
    bulanNama: string
    pemasukan: number
    pengeluaran: number
}

interface RingkasanDashboard {
    totalSaldo: number
    pemasukanBulanIni: number
    pengeluaranBulanIni: number
    selisihBulanIni: number
    pengeluaranPerKategori: PengeluaranPerKategori[]
    trendBulanan: TrendBulanan[]
}

export async function getDashboardAnalytics(): Promise<RingkasanDashboard> {
    try {
        const now = new Date()
        const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)
        const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59)

        // 1. Total Saldo semua akun user
        const totalSaldoResult = await prisma.akun.aggregate({
            where: { tipe: { in: USER_ACCOUNT_TYPES } },
            _sum: { saldoSekarang: true }
        })
        // Convert BigInt -> Float
        const totalSaldo = Money.toFloat(Number(totalSaldoResult._sum.saldoSekarang || 0))

        // 2. Transaksi bulan ini (Parallel Aggregations)
        const [pemasukanResult, pengeluaranResult, kategoriResult] = await Promise.all([
            // Total Pemasukan
            prisma.transaksi.aggregate({
                where: {
                    tanggal: { gte: startOfMonth, lte: endOfMonth },
                    kreditAkun: { tipe: "INCOME" }
                },
                _sum: { nominal: true }
            }),
            // Total Pengeluaran
            prisma.transaksi.aggregate({
                where: {
                    tanggal: { gte: startOfMonth, lte: endOfMonth },
                    debitAkun: { tipe: "EXPENSE" }
                },
                _sum: { nominal: true }
            }),
            // Group by Kategori (hanya untuk pengeluaran)
            prisma.transaksi.groupBy({
                by: ['kategori'],
                where: {
                    tanggal: { gte: startOfMonth, lte: endOfMonth },
                    debitAkun: { tipe: "EXPENSE" }
                },
                _sum: { nominal: true },
                _count: { id: true },
                orderBy: { _sum: { nominal: 'desc' } }
            })
        ])

        const pemasukanBulanIni = Money.toFloat(Number(pemasukanResult._sum.nominal || 0))
        const pengeluaranBulanIni = Money.toFloat(Number(pengeluaranResult._sum.nominal || 0))
        
        const pengeluaranPerKategori: PengeluaranPerKategori[] = kategoriResult.map(item => ({
            kategori: item.kategori,
            total: Money.toFloat(Number(item._sum.nominal || 0)),
            jumlah: item._count.id
        }))

        // 3. Trend 6 bulan terakhir (OPTIMIZED)
        const namaBulan = ['Jan', 'Feb', 'Mar', 'Apr', 'Mei', 'Jun', 'Jul', 'Ags', 'Sep', 'Okt', 'Nov', 'Des']
        const trendBulanan: TrendBulanan[] = []

        const sixMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 5, 1)
        const sixMonthsEnd = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59)
        
        // Single Query
        const transactions = await prisma.transaksi.findMany({
            where: {
                tanggal: { gte: sixMonthsAgo, lte: sixMonthsEnd },
                OR: [
                    { debitAkun: { tipe: "EXPENSE" } },
                    { kreditAkun: { tipe: "INCOME" } }
                ]
            },
            select: {
                tanggal: true,
                nominal: true,
                debitAkun: { select: { tipe: true } },
                kreditAkun: { select: { tipe: true } }
            }
        })

        // Group in-memory
        const monthlyStats: Record<string, { income: number, expense: number }> = {}
        
        for (const tx of transactions) {
            const monthKey = `${tx.tanggal.getFullYear()}-${String(tx.tanggal.getMonth() + 1).padStart(2, '0')}`
            if (!monthlyStats[monthKey]) monthlyStats[monthKey] = { income: 0, expense: 0 }
            
            const nominal = Money.toFloat(Number(tx.nominal))
            
            if (tx.kreditAkun?.tipe === "INCOME") {
                monthlyStats[monthKey].income += nominal
            }
            if (tx.debitAkun?.tipe === "EXPENSE") {
                monthlyStats[monthKey].expense += nominal
            }
        }
        
        // Format Result
        for (let i = 5; i >= 0; i--) {
            const targetDate = new Date(now.getFullYear(), now.getMonth() - i, 1)
            const monthKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}`
            
            const stats = monthlyStats[monthKey] || { income: 0, expense: 0 }
            
            trendBulanan.push({
                bulan: monthKey,
                bulanNama: namaBulan[targetDate.getMonth()],
                pemasukan: stats.income,
                pengeluaran: stats.expense
            })
        }

        return {
            totalSaldo,
            pemasukanBulanIni,
            pengeluaranBulanIni,
            selisihBulanIni: pemasukanBulanIni - pengeluaranBulanIni,
            pengeluaranPerKategori,
            trendBulanan
        }

    } catch (error) {
        await logSistem("ERROR", "ANALYTICS", "Gagal mengambil data analytics", (error as Error).stack)
        throw new Error("Gagal mengambil data analytics")
    }
}

// ============================================
// ENHANCED ANALYTICS FUNCTIONS
// ============================================

interface TrendDataPoint {
    tanggal: string
    saldo: number
}

interface MonthlyComparison {
    kategori: string
    bulanIni: number
    bulanLalu: number
    persentasePerubahan: number
}

interface AccountComposition {
    nama: string
    tipe: string
    saldo: number
    warna: string
    persentase: number
}

// Trend saldo harian 30 hari terakhir
export async function getSaldoTrend(days: number = 30) {
    try {
        const endDate = new Date()
        const startDate = new Date()
        startDate.setDate(startDate.getDate() - days)
        startDate.setHours(0, 0, 0, 0)

        // 1. Ambil saldo awal (saldoAwal di tabel Akun) - BigInt
        const accounts = await prisma.akun.findMany({
            where: { tipe: { in: USER_ACCOUNT_TYPES } },
            select: { id: true, saldoAwal: true }
        })
        let totalInitialBalanceInt = accounts.reduce((sum, acc) => sum + acc.saldoAwal, BigInt(0))

        // 2. Ambil akumulasi mutasi transaksi SEBELUM startDate - BigInt
        const [pastDebit, pastKredit] = await Promise.all([
            prisma.transaksi.aggregate({
                where: {
                    tanggal: { lt: startDate },
                    debitAkun: { tipe: { in: USER_ACCOUNT_TYPES } }
                },
                _sum: { nominal: true }
            }),
            prisma.transaksi.aggregate({
                where: {
                    tanggal: { lt: startDate },
                    kreditAkun: { tipe: { in: USER_ACCOUNT_TYPES } }
                },
                _sum: { nominal: true }
            })
        ])

        // Saldo pada H-1 dari startDate (BigInt)
        let runningBalanceInt = totalInitialBalanceInt + (pastDebit._sum.nominal || BigInt(0)) - (pastKredit._sum.nominal || BigInt(0))

        // 3. Ambil mutasi transaksi HARIAN dalam range (startDate s/d endDate)
        const transactionsInRange = await prisma.transaksi.findMany({
            where: {
                tanggal: { gte: startDate, lte: endDate }
            },
            select: {
                tanggal: true,
                nominal: true,
                debitAkun: { select: { tipe: true } },
                kreditAkun: { select: { tipe: true } }
            },
            orderBy: { tanggal: 'asc' }
        })

        // Group mutasi per hari
        const dailyMutations: Record<string, bigint> = {}
        for (const tx of transactionsInRange) {
            const dateStr = tx.tanggal.toISOString().split('T')[0]
            let mutation = BigInt(0)
            if (tx.debitAkun && USER_ACCOUNT_TYPES.includes(tx.debitAkun.tipe)) {
                mutation += tx.nominal
            }
            if (tx.kreditAkun && USER_ACCOUNT_TYPES.includes(tx.kreditAkun.tipe)) {
                mutation -= tx.nominal
            }
            dailyMutations[dateStr] = (dailyMutations[dateStr] || BigInt(0)) + mutation
        }

        // 4. Bangun data trend harian
        const trendData: TrendDataPoint[] = []
        for (let i = 0; i <= days; i++) {
            const targetDate = new Date(startDate)
            targetDate.setDate(startDate.getDate() + i)
            const dateStr = targetDate.toISOString().split('T')[0]

            runningBalanceInt += (dailyMutations[dateStr] || BigInt(0))
            
            trendData.push({
                tanggal: dateStr,
                saldo: Money.toFloat(Number(runningBalanceInt))
            })
        }

        return { success: true, data: trendData }
    } catch (error) {
        console.error("[ANALYTICS] getSaldoTrend error:", error)
        return { success: false, data: [] }
    }
}

// Perbandingan bulan ini vs bulan lalu per kategori
export async function getMonthlyComparison() {
    try {
        const now = new Date()
        const thisMonth = now.getMonth()
        const thisYear = now.getFullYear()

        // Bulan lalu
        let lastMonth = thisMonth - 1
        let lastMonthYear = thisYear
        if (lastMonth < 0) {
            lastMonth = 11
            lastMonthYear = thisYear - 1
        }

        // Range bulan ini
        const thisMonthStart = new Date(thisYear, thisMonth, 1)
        const thisMonthEnd = new Date(thisYear, thisMonth + 1, 0, 23, 59,
... (truncated)
```

## File: src\app\actions\anggaran.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

export interface BudgetData {
    kategori: string
    bulan: number  // 1-12
    tahun: number  // 2024, 2025, etc
    nominal: number
}

// Buat atau update budget
export async function upsertBudget(data: BudgetData) {
    try {
        // Validasi
        if (data.nominal <= 0) {
            return { success: false, error: "Nominal harus lebih dari 0" }
        }

        if (data.bulan < 1 || data.bulan > 12) {
            return { success: false, error: "Bulan harus antara 1-12" }
        }

        // Cari existing budget
        const existing = await prisma.budget.findFirst({
            where: {
                kategori: data.kategori,
                bulan: data.bulan,
                tahun: data.tahun,
            }
        })

        let budget
        if (existing) {
            // Update
            budget = await prisma.budget.update({
                where: { id: existing.id },
                data: { nominal: data.nominal }
            })
            await logSistem("INFO", "BUDGET", `Budget diperbarui: ${data.kategori} ${data.bulan}/${data.tahun}`)
        } else {
            // Create
            budget = await prisma.budget.create({
                data: {
                    kategori: data.kategori,
                    bulan: data.bulan,
                    tahun: data.tahun,
                    nominal: data.nominal,
                }
            })
            await logSistem("INFO", "BUDGET", `Budget dibuat: ${data.kategori} ${data.bulan}/${data.tahun}`)
        }

        revalidatePath("/anggaran")
        revalidatePath("/")

        return { success: true, data: budget }
    } catch (error) {
        await logSistem("ERROR", "BUDGET", "Gagal menyimpan budget", (error as Error).stack)
        return { success: false, error: "Gagal menyimpan budget" }
    }
}

// Ambil budget untuk bulan tertentu
export async function getBudgetByMonth(bulan: number, tahun: number) {
    try {
        const budgets = await prisma.budget.findMany({
            where: { bulan, tahun },
            orderBy: { kategori: "asc" }
        })
        return { success: true, data: budgets }
    } catch (error) {
        await logSistem("ERROR", "BUDGET", "Gagal mengambil budget", (error as Error).stack)
        return { success: false, data: [], error: "Gagal mengambil budget" }
    }
}

// Ambil budget dengan realisasi pengeluaran
export async function getBudgetWithRealization(bulan: number, tahun: number) {
    try {
        // Ambil semua budget untuk bulan ini
        const budgets = await prisma.budget.findMany({
            where: { bulan, tahun },
            orderBy: { kategori: "asc" }
        })

        // Ambil pengeluaran per kategori untuk bulan ini
        const startDate = new Date(tahun, bulan - 1, 1)
        const endDate = new Date(tahun, bulan, 0, 23, 59, 59)

        const transaksi = await prisma.transaksi.findMany({
            where: {
                tanggal: { gte: startDate, lte: endDate },
                debitAkun: { tipe: "EXPENSE" }
            }
        })

        // Group by kategori
        const realisasiMap = new Map<string, number>()
        for (const tx of transaksi) {
            const current = realisasiMap.get(tx.kategori) || 0
            // Convert BigInt to Float
            const nominal = Money.toFloat(Number(tx.nominal))
            realisasiMap.set(tx.kategori, current + nominal)
        }

        // Hitung sisa hari
        const now = new Date()
        const isCurrentMonth = now.getMonth() + 1 === bulan && now.getFullYear() === tahun
        let sisaHari = 0
        if (isCurrentMonth) {
            const lastDay = new Date(tahun, bulan, 0).getDate()
            sisaHari = lastDay - now.getDate() + 1
        } else {
            const targetMonth = new Date(tahun, bulan - 1, 1)
            if (targetMonth > now) {
                sisaHari = new Date(tahun, bulan, 0).getDate()
            }
        }

        // Gabungkan budget dengan realisasi
        const result = budgets.map(b => {
            const realisasi = realisasiMap.get(b.kategori) || 0
            const sisa = b.nominal - realisasi
            return {
                ...b,
                realisasi,
                persentase: Math.round((realisasi / b.nominal) * 100),
                sisa,
                saranHarian: sisa > 0 && sisaHari > 0 ? Math.floor(sisa / sisaHari) : 0,
            }
        })

        // Tambahkan kategori yang ada pengeluaran tapi tidak ada budget
        const budgetKategori = new Set(budgets.map(b => b.kategori))
        const unbudgetedCategories: any[] = []
        realisasiMap.forEach((nominal, kategori) => {
            if (!budgetKategori.has(kategori)) {
                unbudgetedCategories.push({
                    id: null,
                    kategori,
                    bulan,
                    tahun,
                    nominal: 0,  // Tidak ada budget
                    realisasi: nominal,
                    persentase: 100,
                    sisa: -nominal,
                    noBudget: true,
                })
            }
        })

        return {
            success: true,
            data: {
                budgets: result,
                unbudgeted: unbudgetedCategories,
                totalBudget: budgets.reduce((sum, b) => sum + b.nominal, 0),
                totalRealisasi: Array.from(realisasiMap.values()).reduce((sum, n) => sum + n, 0),
                sisaHari,
            }
        }
    } catch (error) {
        await logSistem("ERROR", "BUDGET", "Gagal mengambil budget dengan realisasi", (error as Error).stack)
        return {
            success: false,
            data: { budgets: [], unbudgeted: [], totalBudget: 0, totalRealisasi: 0 }
        }
    }
}

// Hapus budget
export async function deleteBudget(id: string) {
    try {
        const budget = await prisma.budget.delete({
            where: { id }
        })

        await logSistem("INFO", "BUDGET", `Budget dihapus: ${budget.kategori}`)
        revalidatePath("/anggaran")

        return { success: true }
    } catch (error) {
        await logSistem("ERROR", "BUDGET", "Gagal menghapus budget", (error as Error).stack)
        return { success: false, error: "Gagal menghapus budget" }
    }
}

// Salin budget dari bulan sebelumnya
export async function copyBudgetFromPreviousMonth(bulan: number, tahun: number) {
    try {
        // Hitung bulan sebelumnya
        let prevBulan = bulan - 1
        let prevTahun = tahun
        if (prevBulan < 1) {
            prevBulan = 12
            prevTahun = tahun - 1
        }

        // Ambil budget bulan sebelumnya
        const prevBudgets = await prisma.budget.findMany({
            where: { bulan: prevBulan, tahun: prevTahun }
        })

        if (prevBudgets.length === 0) {
            return { success: false, error: "Tidak ada budget di bulan sebelumnya" }
        }

        // Salin ke bulan ini
        let created = 0
        for (const pb of prevBudgets) {
            // Cek apakah sudah ada
            const existing = await prisma.budget.findFirst({
                where: { kategori: pb.kategori, bulan, tahun }
            })

            if (!existing) {
                await prisma.budget.create({
                    data: {
                        kategori: pb.kategori,
                        bulan,
                        tahun,
                        nominal: pb.nominal,
                    }
                })
                created++
            }
        }

        await logSistem("INFO", "BUDGET", `Budget disalin dari ${prevBulan}/${prevTahun}: ${created} kategori`)
        revalidatePath("/anggaran")

        return { success: true, copied: created }
    } catch (error) {
        await logSistem("ERROR", "BUDGET", "Gagal menyalin budget", (error as Error).stack)
        return { success: false, error: "Gagal menyalin budget" }
    }
}

// Dapatkan kategori yang sudah pernah digunakan
export async function getAvailableCategories() {
    try {
        // Ambil dari akun expense
        const expenseAccounts = await prisma.akun.findMany({
            where: { tipe: "EXPENSE" },
            select: { nama: true }
        })

        // Extract kategori dari nama akun "[EXPENSE] Kategori"
        const categories = expenseAccounts
            .map(a => a.nama.replace("[EXPENSE] ", ""))
            .filter(k => k.length > 0)
            .sort()

        return { success: true, data: categories }
    } catch (error) {
        return { success: false, data: [] }
    }
}

// Dapatkan bulan yang tersedia
export async function getAvailableBudgetMonths() {
    try {
        const budgets = await prisma.budget.findMany({
            select: { bulan: true, tahun: true },
            distinct: ["bulan", "tahun"],
            orderBy: [{ tahun: "desc" }, { bulan: "desc" }]
        })

        return { success: true, data: budgets }
    } catch (error) {
        return { success: false, data: [] }
    }
}

```

## File: src\app\actions\backup.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"

// Struktur backup data
interface BackupData {
    version: string
    createdAt: string
    data: {
        akun: any[]
        transaksi: any[]
        rencanaCicilan: any[]
        recurringTransaction: any[]
        budget: any[]
        logSistem: any[]
    }
    stats: {
        totalAkun: number
        totalTransaksi: number
        totalCicilan: number
        totalRecurring: number
        totalBudget: number
    }
}

// Ekspor semua data ke JSON
export async function exportBackup(): Promise<{ success: boolean; data?: BackupData; error?: string }> {
    try {
        await logSistem("INFO", "BACKUP", "Memulai proses backup data")

        // Ambil semua data dari database
        const [akun, transaksi, rencanaCicilan, recurringTransaction, budget, logData] = await Promise.all([
            prisma.akun.findMany({ orderBy: { createdAt: "asc" } }),
            prisma.transaksi.findMany({ orderBy: { tanggal: "asc" } }),
            prisma.rencanaCicilan.findMany({ orderBy: { createdAt: "asc" } }),
            prisma.recurringTransaction.findMany({ orderBy: { createdAt: "asc" } }),
            prisma.budget.findMany({ orderBy: { createdAt: "asc" } }),
            prisma.logSistem.findMany({ orderBy: { createdAt: "asc" }, take: 1000 }), // Limit 1000 log
        ])

        const backup: BackupData = {
            version: "1.0.0",
            createdAt: new Date().toISOString(),
            data: {
                akun,
                transaksi,
                rencanaCicilan,
                recurringTransaction,
                budget,
                logSistem: logData,
            },
            stats: {
                totalAkun: akun.length,
                totalTransaksi: transaksi.length,
                totalCicilan: rencanaCicilan.length,
                totalRecurring: recurringTransaction.length,
                totalBudget: budget.length,
            }
        }

        await logSistem("INFO", "BACKUP", `Backup berhasil: ${transaksi.length} transaksi, ${akun.length} akun`)

        return { success: true, data: backup }
    } catch (error) {
        await logSistem("ERROR", "BACKUP", "Gagal melakukan backup", (error as Error).stack)
        return { success: false, error: "Gagal melakukan backup data" }
    }
}

// Import/Restore data dari backup
export async function importBackup(backupJson: string): Promise<{
    success: boolean
    message?: string
    stats?: { imported: any; skipped: any }
    error?: string
}> {
    try {
        await logSistem("INFO", "RESTORE", "Memulai proses restore data")

        // Parse backup JSON
        let backup: BackupData
        try {
            backup = JSON.parse(backupJson)
        } catch {
            return { success: false, error: "Format backup tidak valid (bukan JSON)" }
        }

        // Validasi struktur backup
        if (!backup.version || !backup.data) {
            return { success: false, error: "Struktur backup tidak valid" }
        }

        const imported = { akun: 0, transaksi: 0, cicilan: 0, recurring: 0, budget: 0 }
        const skipped = { akun: 0, transaksi: 0, cicilan: 0, recurring: 0, budget: 0 }
        const updated = { akun: 0 }

        // Mapping dari old ID ke new ID (untuk akun yang sudah ada)
        const akunIdMap = new Map<string, string>()

        // Restore akun terlebih dahulu (karena ada relasi)
        for (const akun of backup.data.akun || []) {
            try {
                // Cek duplikat berdasarkan NAMA dan TIPE (bukan id)
                const existing = await prisma.akun.findFirst({
                    where: {
                        nama: akun.nama,
                        tipe: akun.tipe
                    }
                })

                if (existing) {
                    // Akun dengan nama dan tipe sama sudah ada
                    // Update saldo dari backup dan simpan mapping
                    await prisma.akun.update({
                        where: { id: existing.id },
                        data: {
                            saldoSekarang: akun.saldoSekarang,
                            saldoAwal: akun.saldoAwal,
                            warna: akun.warna,
                            limitKredit: akun.limitKredit,
                        }
                    })
                    akunIdMap.set(akun.id, existing.id)
                    updated.akun++
                    continue
                }

                // Cek apakah ID sudah ada (untuk menghindari conflict)
                const existingById = await prisma.akun.findUnique({ where: { id: akun.id } })

                if (existingById) {
                    // ID sama tapi nama/tipe beda = skip
                    akunIdMap.set(akun.id, existingById.id)
                    skipped.akun++
                    continue
                }

                // Buat akun baru dengan ID dari backup
                await prisma.akun.create({
                    data: {
                        id: akun.id,
                        nama: akun.nama,
                        tipe: akun.tipe,
                        saldoAwal: akun.saldoAwal,
                        saldoSekarang: akun.saldoSekarang,
                        warna: akun.warna,
                        limitKredit: akun.limitKredit,
                        createdAt: new Date(akun.createdAt),
                    }
                })
                akunIdMap.set(akun.id, akun.id)
                imported.akun++
            } catch (err) {
                skipped.akun++
            }
        }

        // Restore transaksi
        for (const tx of backup.data.transaksi || []) {
            try {
                const existing = await prisma.transaksi.findUnique({ where: { id: tx.id } })
                if (existing) {
                    skipped.transaksi++
                    continue
                }

                await prisma.transaksi.create({
                    data: {
                        id: tx.id,
                        deskripsi: tx.deskripsi,
                        nominal: tx.nominal,
                        kategori: tx.kategori,
                        tanggal: new Date(tx.tanggal),
                        catatan: tx.catatan,
                        debitAkunId: tx.debitAkunId,
                        kreditAkunId: tx.kreditAkunId,
                        idempotencyKey: tx.idempotencyKey,
                        rencanaCicilanId: tx.rencanaCicilanId,
                        createdAt: new Date(tx.createdAt),
                    }
                })
                imported.transaksi++
            } catch (err) {
                skipped.transaksi++
            }
        }

        // Restore cicilan
        for (const cicilan of backup.data.rencanaCicilan || []) {
            try {
                const existing = await prisma.rencanaCicilan.findUnique({ where: { id: cicilan.id } })
                if (existing) {
                    skipped.cicilan++
                    continue
                }

                await prisma.rencanaCicilan.create({
                    data: {
                        id: cicilan.id,
                        namaProduk: cicilan.namaProduk,
                        totalPokok: cicilan.totalPokok,
                        tenor: cicilan.tenor,
                        cicilanKe: cicilan.cicilanKe,
                        nominalPerBulan: cicilan.nominalPerBulan,
                        biayaAdmin: cicilan.biayaAdmin,
                        bungaPersen: cicilan.bungaPersen,
                        tanggalJatuhTempo: cicilan.tanggalJatuhTempo,
                        status: cicilan.status,
                        akunKreditId: cicilan.akunKreditId,
                        akunDebitId: cicilan.akunDebitId,
                        createdAt: new Date(cicilan.createdAt),
                        updatedAt: new Date(cicilan.updatedAt),
                    }
                })
                imported.cicilan++
            } catch (err) {
                skipped.cicilan++
            }
        }

        // Restore recurring
        for (const recurring of backup.data.recurringTransaction || []) {
            try {
                const existing = await prisma.recurringTransaction.findUnique({ where: { id: recurring.id } })
                if (existing) {
                    skipped.recurring++
                    continue
                }

                await prisma.recurringTransaction.create({
                    data: {
                        id: recurring.id,
                        nama: recurring.nama,
                        nominal: recurring.nominal,
                        kategori: recurring.kategori,
                        tipeTransaksi: recurring.tipeTransaksi,
                        akunId: recurring.akunId,
                        frekuensi: recurring.frekuensi,
                        hariDalamBulan: recurring.hariDalamBulan,
                        hariDalamMinggu: recurring.hariDalamMinggu,
                        aktif: recurring.aktif,
                        createdAt: new Date(recurring.createdAt),
                    }
                })
                imported.recurring++
            } catch (err) {
                skipped.recurring++
            }
        }

        // Restore budget
        for (const budget of backup.data.budget || []) {
            try {
                const existing = await prisma.budget.findUnique({ where: { id: budget.id } })
                if (existing) {
                    skipped.budget++
                    continue
                }

                await prism
... (truncated)
```

## File: src\app\actions\calendar.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { Money } from "@/lib/money"

export interface CalendarEvent {
    id: string
    date: Date
    type: 'cicilan' | 'recurring' | 'transaksi'
    title: string
    nominal: number
    description?: string
    color: string
}

// Ambil event untuk kalender (cicilan, recurring, transaksi)
export async function getCalendarEvents(bulan: number, tahun: number) {
    try {
        const startDate = new Date(tahun, bulan - 1, 1)
        const endDate = new Date(tahun, bulan, 0, 23, 59, 59)

        // Ambil cicilan aktif
        const cicilanAktif = await prisma.rencanaCicilan.findMany({
            where: {
                status: "AKTIF",
            }
        })

        // Ambil recurring transactions (tanpa include karena tidak ada relasi)
        const recurring = await prisma.recurringTransaction.findMany({
            where: {
                aktif: true
            }
        })

        // Ambil transaksi bulan ini
        const transaksi = await prisma.transaksi.findMany({
            where: {
                tanggal: { gte: startDate, lte: endDate }
            },
            include: {
                kreditAkun: true,
                debitAkun: true
            },
            orderBy: { tanggal: 'asc' }
        })

        const events: CalendarEvent[] = []

        // Process cicilan - tanggal jatuh tempo
        for (const cicilan of cicilanAktif) {
            // Gunakan tanggalJatuhTempo (1-31)
            const tanggal = cicilan.tanggalJatuhTempo
            const lastDayOfMonth = new Date(tahun, bulan, 0).getDate()
            const jatuhTempo = new Date(tahun, bulan - 1, Math.min(tanggal, lastDayOfMonth))

            // Pastikan tanggal masih dalam bulan ini
            if (jatuhTempo >= startDate && jatuhTempo <= endDate) {
                const sisaBulan = cicilan.tenor - cicilan.cicilanKe + 1
                events.push({
                    id: `cicilan-${cicilan.id}`,
                    date: jatuhTempo,
                    type: 'cicilan',
                    title: cicilan.namaProduk,
                    nominal: Money.toFloat(Number(cicilan.nominalPerBulan)), // BigInt
                    description: `Cicilan ke-${cicilan.cicilanKe} dari ${cicilan.tenor} - Sisa ${sisaBulan} bulan`,
                    color: '#f59e0b' // amber
                })
            }
        }

        // Process recurring transactions
        for (const rec of recurring) {
            switch (rec.frekuensi) {
                case 'HARIAN':
                    // Tampilkan untuk tanggal 1, 15, dan akhir bulan (simplified)
                    const lastDay = new Date(tahun, bulan, 0).getDate()
                        ;[1, 15, lastDay].forEach(day => {
                            events.push({
                                id: `recurring-${rec.id}-${day}`,
                                date: new Date(tahun, bulan - 1, day),
                                type: 'recurring',
                                title: rec.nama,
                                nominal: rec.nominal, // Float
                                description: `${rec.kategori} - Harian`,
                                color: '#8b5cf6' // violet
                            })
                        })
                    break

                case 'MINGGUAN':
                    // Tampilkan setiap minggu
                    [1, 8, 15, 22, 29].forEach(day => {
                        if (day <= new Date(tahun, bulan, 0).getDate()) {
                            events.push({
                                id: `recurring-${rec.id}-${day}`,
                                date: new Date(tahun, bulan - 1, day),
                                type: 'recurring',
                                title: rec.nama,
                                nominal: rec.nominal, // Float
                                description: `${rec.kategori} - Mingguan`,
                                color: '#8b5cf6'
                            })
                        }
                    })
                    break

                case 'BULANAN':
                    // Gunakan hariDalamBulan atau tanggal 1
                    const tanggalBulanan = rec.hariDalamBulan || 1
                    const maxDay = new Date(tahun, bulan, 0).getDate()
                    events.push({
                        id: `recurring-${rec.id}`,
                        date: new Date(tahun, bulan - 1, Math.min(tanggalBulanan, maxDay)),
                        type: 'recurring',
                        title: rec.nama,
                        nominal: rec.nominal, // Float
                        description: `${rec.kategori} - Bulanan`,
                        color: '#8b5cf6'
                    })
                    break

                case 'TAHUNAN':
                    // Cek apakah bulan ini sesuai dengan tanggal mulai
                    const startMonth = rec.tanggalMulai.getMonth() + 1
                    if (startMonth === bulan) {
                        events.push({
                            id: `recurring-${rec.id}`,
                            date: new Date(tahun, bulan - 1, rec.tanggalMulai.getDate()),
                            type: 'recurring',
                            title: rec.nama,
                            nominal: rec.nominal, // Float
                            description: `${rec.kategori} - Tahunan`,
                            color: '#8b5cf6'
                        })
                    }
                    break
            }
        }

        // Process transaksi
        for (const tx of transaksi) {
            // Skip internal transfers
            const isExpense = tx.debitAkun?.tipe === 'EXPENSE'
            const isIncome = tx.kreditAkun?.tipe === 'INCOME'

            if (isExpense || isIncome) {
                events.push({
                    id: `transaksi-${tx.id}`,
                    date: tx.tanggal,
                    type: 'transaksi',
                    title: tx.deskripsi,
                    nominal: Money.toFloat(Number(tx.nominal)), // BigInt
                    description: isExpense ? `Pengeluaran - ${tx.kategori}` : `Pemasukan - ${tx.kategori}`,
                    color: isExpense ? '#ef4444' : '#22c55e' // red for expense, green for income
                })
            }
        }

        // Sort by date
        events.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime())

        return { success: true, data: events }
    } catch (error) {
        console.error('Error fetching calendar events:', error)
        return { success: false, data: [] }
    }
}

// Ambil ringkasan untuk header kalender
export async function getCalendarSummary(bulan: number, tahun: number) {
    try {
        const startDate = new Date(tahun, bulan - 1, 1)
        const endDate = new Date(tahun, bulan, 0, 23, 59, 59)

        // Hitung total cicilan bulan ini
        const cicilanAktif = await prisma.rencanaCicilan.count({
            where: { status: "AKTIF" }
        })

        const totalCicilan = await prisma.rencanaCicilan.aggregate({
            where: { status: "AKTIF" },
            _sum: { nominalPerBulan: true }
        })

        // Hitung recurring aktif
        const recurringCount = await prisma.recurringTransaction.count({
            where: { aktif: true }
        })

        // Hitung transaksi bulan ini
        const transaksiCount = await prisma.transaksi.count({
            where: {
                tanggal: { gte: startDate, lte: endDate }
            }
        })

        return {
            success: true,
            data: {
                cicilanAktif,
                totalCicilan: Money.toFloat(Number(totalCicilan._sum.nominalPerBulan || 0)), // BigInt
                recurringCount,
                transaksiCount
            }
        }
    } catch (error) {
        return {
            success: false,
            data: { cicilanAktif: 0, totalCicilan: 0, recurringCount: 0, transaksiCount: 0 }
        }
    }
}

```

## File: src\app\actions\cicilan.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

export interface CicilanData {
    namaProduk: string
    totalPokok: number
    tenor: number
    nominalPerBulan: number
    biayaAdmin?: number
    bungaPersen?: number
    tanggalJatuhTempo: number  // 1-31
    akunKreditId: string  // Akun kartu kredit
}

// Buat cicilan baru
export async function createCicilan(data: CicilanData) {
    try {
        // Validasi
        if (data.totalPokok <= 0 || data.tenor <= 0 || data.nominalPerBulan <= 0) {
            return { success: false, error: "Nominal dan tenor harus lebih dari 0" }
        }

        if (data.tanggalJatuhTempo < 1 || data.tanggalJatuhTempo > 31) {
            return { success: false, error: "Tanggal jatuh tempo harus antara 1-31" }
        }

        // Cari atau buat akun pengeluaran cicilan
        const namaAkunDebit = "[EXPENSE] Cicilan"
        let akunDebit = await prisma.akun.findFirst({
            where: { nama: namaAkunDebit }
        })

        if (!akunDebit) {
            akunDebit = await prisma.akun.create({
                data: {
                    nama: namaAkunDebit,
                    tipe: "EXPENSE",
                    saldoAwal: BigInt(0),
                    saldoSekarang: BigInt(0),
                }
            })
        }

        const cicilan = await prisma.rencanaCicilan.create({
            data: {
                namaProduk: data.namaProduk,
                totalPokok: BigInt(Money.fromFloat(data.totalPokok)),
                tenor: data.tenor,
                cicilanKe: 1,
                nominalPerBulan: BigInt(Money.fromFloat(data.nominalPerBulan)),
                biayaAdmin: BigInt(Money.fromFloat(data.biayaAdmin || 0)),
                bungaPersen: data.bungaPersen || 0,
                tanggalJatuhTempo: data.tanggalJatuhTempo,
                status: "AKTIF",
                akunKreditId: data.akunKreditId,
                akunDebitId: akunDebit.id,
            },
        })

        await logSistem("INFO", "CICILAN", `Rencana cicilan dibuat: ${cicilan.namaProduk}`)
        revalidatePath("/cicilan")
        revalidatePath("/")

        const mappedCicilan = {
            ...cicilan,
            totalPokok: Money.toFloat(Number(cicilan.totalPokok)),
            nominalPerBulan: Money.toFloat(Number(cicilan.nominalPerBulan)),
            biayaAdmin: Money.toFloat(Number(cicilan.biayaAdmin)),
        }

        return { success: true, data: mappedCicilan }
    } catch (error) {
        await logSistem("ERROR", "CICILAN", "Gagal membuat rencana cicilan", (error as Error).stack)
        return { success: false, error: "Gagal membuat rencana cicilan" }
    }
}

// Ambil semua cicilan
export async function getCicilan() {
    try {
        const cicilan = await prisma.rencanaCicilan.findMany({
            orderBy: [
                { status: "asc" },  // AKTIF dulu
                { createdAt: "desc" }
            ],
        })
        
        const mapped = cicilan.map(c => ({
            ...c,
            totalPokok: Money.toFloat(Number(c.totalPokok)),
            nominalPerBulan: Money.toFloat(Number(c.nominalPerBulan)),
            biayaAdmin: Money.toFloat(Number(c.biayaAdmin)),
        }))

        return { success: true, data: mapped }
    } catch (error) {
        await logSistem("ERROR", "CICILAN", "Gagal mengambil data cicilan", (error as Error).stack)
        return { success: false, data: [], error: "Gagal mengambil data cicilan" }
    }
}

// Ambil cicilan by ID
export async function getCicilanById(id: string) {
    try {
        const cicilan = await prisma.rencanaCicilan.findUnique({
            where: { id },
            include: {
                transaksi: {
                    orderBy: { tanggal: "desc" }
                }
            }
        })
        
        if (!cicilan) return null

        return {
            ...cicilan,
            totalPokok: Money.toFloat(Number(cicilan.totalPokok)),
            nominalPerBulan: Money.toFloat(Number(cicilan.nominalPerBulan)),
            biayaAdmin: Money.toFloat(Number(cicilan.biayaAdmin)),
            transaksi: cicilan.transaksi.map(tx => ({
                ...tx,
                nominal: Money.toFloat(Number(tx.nominal))
            }))
        }
    } catch (error) {
        await logSistem("ERROR", "CICILAN", "Gagal mengambil detail cicilan", (error as Error).stack)
        return null
    }
}

// Bayar cicilan (eksekusi pembayaran bulanan)
export async function bayarCicilan(id: string) {
    try {
        const cicilan = await prisma.rencanaCicilan.findUnique({
            where: { id }
        })

        if (!cicilan) {
            return { success: false, error: "Cicilan tidak ditemukan" }
        }

        if (cicilan.status !== "AKTIF") {
            return { success: false, error: "Cicilan sudah lunas atau dibalikkan" }
        }

        if (cicilan.cicilanKe > cicilan.tenor) {
            return { success: false, error: "Cicilan sudah melebihi tenor" }
        }

        await prisma.$transaction(async (tx: any) => {
            // Buat transaksi pembayaran
            const now = new Date()
            await tx.transaksi.create({
                data: {
                    deskripsi: `Cicilan ${cicilan.namaProduk} (${cicilan.cicilanKe}/${cicilan.tenor})`,
                    nominal: cicilan.nominalPerBulan, // BigInt
                    kategori: "Cicilan",
                    debitAkunId: cicilan.akunDebitId,
                    kreditAkunId: cicilan.akunKreditId,
                    tanggal: now,
                    rencanaCicilanId: cicilan.id,
                    catatan: `Pembayaran cicilan ke-${cicilan.cicilanKe} dari ${cicilan.tenor}`,
                }
            })

            // Update saldo akun
            await tx.akun.update({
                where: { id: cicilan.akunDebitId },
                data: { saldoSekarang: { increment: cicilan.nominalPerBulan } }
            })
            await tx.akun.update({
                where: { id: cicilan.akunKreditId },
                data: { saldoSekarang: { decrement: cicilan.nominalPerBulan } }
            })

            // Update progress cicilan
            const newCicilanKe = cicilan.cicilanKe + 1
            const isLunas = newCicilanKe > cicilan.tenor

            await tx.rencanaCicilan.update({
                where: { id },
                data: {
                    cicilanKe: newCicilanKe,
                    status: isLunas ? "LUNAS" : "AKTIF"
                }
            })
        })

        await logSistem("INFO", "CICILAN", `Pembayaran cicilan: ${cicilan.namaProduk} (${cicilan.cicilanKe}/${cicilan.tenor})`)
        revalidatePath("/cicilan")
        revalidatePath("/transaksi")
        revalidatePath("/akun")
        revalidatePath("/")

        return { success: true }
    } catch (error) {
        await logSistem("ERROR", "CICILAN", "Gagal membayar cicilan", (error as Error).stack)
        return { success: false, error: "Gagal membayar cicilan" }
    }
}

// Pelunasan dipercepat (bayar sisa sekaligus)
export async function pelunasanDipercepat(id: string) {
    try {
        const cicilan = await prisma.rencanaCicilan.findUnique({
            where: { id }
        })

        if (!cicilan) {
            return { success: false, error: "Cicilan tidak ditemukan" }
        }

        if (cicilan.status !== "AKTIF") {
            return { success: false, error: "Cicilan sudah lunas atau dibalikkan" }
        }

        // Hitung sisa yang harus dibayar
        const sisaTenor = cicilan.tenor - cicilan.cicilanKe + 1
        // Use BigInt math
        const sisaNominal = BigInt(sisaTenor) * cicilan.nominalPerBulan

        await prisma.$transaction(async (tx: any) => {
            // Buat transaksi pelunasan
            const now = new Date()
            await tx.transaksi.create({
                data: {
                    deskripsi: `Pelunasan ${cicilan.namaProduk} (sisa ${sisaTenor} bulan)`,
                    nominal: sisaNominal,
                    kategori: "Cicilan",
                    debitAkunId: cicilan.akunDebitId,
                    kreditAkunId: cicilan.akunKreditId,
                    tanggal: now,
                    rencanaCicilanId: cicilan.id,
                    catatan: `Pelunasan dipercepat - sisa ${sisaTenor} dari ${cicilan.tenor} bulan`,
                }
            })

            // Update saldo akun
            await tx.akun.update({
                where: { id: cicilan.akunDebitId },
                data: { saldoSekarang: { increment: sisaNominal } }
            })
            await tx.akun.update({
                where: { id: cicilan.akunKreditId },
                data: { saldoSekarang: { decrement: sisaNominal } }
            })

            // Update status cicilan
            await tx.rencanaCicilan.update({
                where: { id },
                data: {
                    cicilanKe: cicilan.tenor + 1,
                    status: "LUNAS"
                }
            })
        })

        await logSistem("INFO", "CICILAN", `Pelunasan dipercepat: ${cicilan.namaProduk}`)
        revalidatePath("/cicilan")
        revalidatePath("/transaksi")
        revalidatePath("/akun")
        revalidatePath("/")

        return { success: true }
    } catch (error) {
        await logSistem("ERROR", "CICILAN", "Gagal pelunasan dipercepat", (error as Error).stack)
        return { success: false, error: "Gagal pelunasan dipercepat" }
    }
}

// Update cicilan (hanya untuk field tertentu)
export async function updateCicilan(id: string, data: {
    namaProduk?: string
    tanggalJatuhTempo?: number
    biayaAdmin?: number
    bungaPersen?: number
}) {
    try {
        const updateData: any = { ...data }
        if (data.biayaAdmin !== undefined) {
            updateData.biayaAdmin = BigInt(Money.fromFloat(data.biayaAdmin))
        }

        const c
... (truncated)
```

## File: src\app\actions\credit-card-payment.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import {
    getBillingPeriod,
    getDueDateInfo,
    calculateLateFee,
    calculateMinimumPayment
} from "@/lib/decimal-utils"
import { Money } from "@/lib/money"

// Interface untuk hasil kalkulasi pembayaran
export interface PaymentCalculation {
    fullPayment: number
    minimumPayment: number
    lateFee: number
    breakdown: {
        purchases: number
        installments: number
        fees: number
        previousBalance: number
    }
    billingPeriod: { start: Date; end: Date }
    dueDate: Date
    daysUntilDue: number
    isPastDue: boolean
    isValid: boolean
    validationError?: string
}

// Kategori yang dianggap sebagai biaya/denda
const FEE_CATEGORIES = ["Biaya", "Denda", "Admin", "Bunga", "Late Fee"]

/**
 * Validate credit card has all mandatory fields
 */
export async function validateCreditCardMandatoryFields(akunId: string): Promise<{
    isValid: boolean
    error?: string
}> {
    try {
        const akun = await prisma.akun.findUnique({
            where: { id: akunId }
        })

        if (!akun) {
            return { isValid: false, error: "Akun tidak ditemukan" }
        }

        if (akun.tipe !== "CREDIT_CARD") {
            return { isValid: false, error: "Akun bukan kartu kredit" }
        }

        const missingFields: string[] = []

        if (akun.isSyariah === null || akun.isSyariah === undefined) {
            missingFields.push("Tipe Kartu (Syariah/Konvensional)")
        }
        if (!akun.billingDate) {
            missingFields.push("Tanggal Billing")
        }
        if (!akun.dueDate) {
            missingFields.push("Tanggal Jatuh Tempo")
        }
        if (!akun.minPaymentFixed) {
            missingFields.push("Minimum Payment")
        }

        if (missingFields.length > 0) {
            return {
                isValid: false,
                error: `Field wajib belum diisi: ${missingFields.join(", ")}`
            }
        }

        return { isValid: true }
    } catch (error) {
        await logSistem("ERROR", "CREDIT_CARD", "Gagal validasi field kartu kredit", (error as Error).stack)
        return { isValid: false, error: "Gagal memvalidasi kartu kredit" }
    }
}

/**
 * Calculate credit card payment with full breakdown
 */
export async function calculateCreditCardPayment(akunId: string): Promise<PaymentCalculation> {
    try {
        // Get account details
        const akun = await prisma.akun.findUnique({
            where: { id: akunId }
        })

        if (!akun) {
            return {
                fullPayment: 0,
                minimumPayment: 0,
                lateFee: 0,
                breakdown: { purchases: 0, installments: 0, fees: 0, previousBalance: 0 },
                billingPeriod: { start: new Date(), end: new Date() },
                dueDate: new Date(),
                daysUntilDue: 0,
                isPastDue: false,
                isValid: false,
                validationError: "Akun tidak ditemukan"
            }
        }

        const saldoSekarangFloat = Money.toFloat(Number(akun.saldoSekarang))

        // Validate mandatory fields
        const validation = await validateCreditCardMandatoryFields(akunId)
        if (!validation.isValid) {
            return {
                fullPayment: Math.abs(saldoSekarangFloat),
                minimumPayment: 0,
                lateFee: 0,
                breakdown: { purchases: 0, installments: 0, fees: 0, previousBalance: Math.abs(saldoSekarangFloat) },
                billingPeriod: { start: new Date(), end: new Date() },
                dueDate: new Date(),
                daysUntilDue: 0,
                isPastDue: false,
                isValid: false,
                validationError: validation.error
            }
        }

        // Get billing period
        const billingPeriod = getBillingPeriod(akun.billingDate!)

        // Get due date info
        const dueDateInfo = getDueDateInfo(akun.dueDate!, akun.billingDate!)

        // Fetch transactions in billing period where this account is credited (money out = debt increases)
        const transactions = await prisma.transaksi.findMany({
            where: {
                kreditAkunId: akunId,
                tanggal: {
                    gte: billingPeriod.start,
                    lte: billingPeriod.end
                }
            },
            include: {
                rencanaCicilan: true
            }
        })

        // Categorize transactions
        let purchases = 0
        let installments = 0
        let fees = 0

        for (const tx of transactions) {
            const nominal = Money.toFloat(Number(tx.nominal))

            // Check if it's an installment payment
            if (tx.rencanaCicilanId) {
                installments += nominal
                continue
            }

            // Check if it's a fee/penalty
            const isFee = FEE_CATEGORIES.some(cat =>
                tx.kategori.toLowerCase().includes(cat.toLowerCase())
            )
            if (isFee) {
                fees += nominal
                continue
            }

            // Regular purchase
            purchases += nominal
        }

        // Previous balance = current balance - this period's transactions
        // In credit cards, saldoSekarang is typically negative (debt)
        const thisMonthTotal = purchases + installments + fees
        const previousBalance = Math.max(0, Math.abs(saldoSekarangFloat) - thisMonthTotal)

        // Calculate full payment
        const fullPayment = purchases + installments + fees + previousBalance

        // Calculate minimum payment
        const minPaymentFixedFloat = akun.minPaymentFixed ? Money.toFloat(Number(akun.minPaymentFixed)) : 50000
        const minimumPayment = calculateMinimumPayment(
            fullPayment,
            akun.minPaymentPercent || 5,
            minPaymentFixedFloat
        )

        // Calculate late fee (only if past due)
        const daysPastDue = dueDateInfo.isPastDue ? Math.abs(dueDateInfo.daysUntilDue) : 0
        const lateFee = calculateLateFee(fullPayment, akun.isSyariah || false, daysPastDue)

        await logSistem("INFO", "CREDIT_CARD",
            `Kalkulasi tagihan ${akun.nama}: Total ${fullPayment.toLocaleString('id-ID')}`)

        return {
            fullPayment,
            minimumPayment,
            lateFee,
            breakdown: {
                purchases,
                installments,
                fees,
                previousBalance
            },
            billingPeriod,
            dueDate: dueDateInfo.dueDateTime,
            daysUntilDue: dueDateInfo.daysUntilDue,
            isPastDue: dueDateInfo.isPastDue,
            isValid: true
        }
    } catch (error) {
        await logSistem("ERROR", "CREDIT_CARD", "Gagal menghitung tagihan kartu kredit", (error as Error).stack)
        return {
            fullPayment: 0,
            minimumPayment: 0,
            lateFee: 0,
            breakdown: { purchases: 0, installments: 0, fees: 0, previousBalance: 0 },
            billingPeriod: { start: new Date(), end: new Date() },
            dueDate: new Date(),
            daysUntilDue: 0,
            isPastDue: false,
            isValid: false,
            validationError: "Terjadi kesalahan saat menghitung tagihan"
        }
    }
}

/**
 * Get credit card account with full details
 */
export async function getCreditCardDetail(akunId: string) {
    try {
        const akun = await prisma.akun.findUnique({
            where: { id: akunId },
            include: {
                adminFees: {
                    where: { isActive: true },
                    include: {
                        recurringTx: true
                    }
                }
            }
        })

        if (!akun || akun.tipe !== "CREDIT_CARD") {
            return { success: false, error: "Akun kartu kredit tidak ditemukan" }
        }
        
        const mappedAkun = {
            ...akun,
            saldoSekarang: Money.toFloat(Number(akun.saldoSekarang)),
            saldoAwal: Money.toFloat(Number(akun.saldoAwal)),
            limitKredit: akun.limitKredit ? Money.toFloat(Number(akun.limitKredit)) : null,
            minPaymentFixed: akun.minPaymentFixed ? Money.toFloat(Number(akun.minPaymentFixed)) : null,
            minInstallmentAmount: akun.minInstallmentAmount ? Money.toFloat(Number(akun.minInstallmentAmount)) : null,
        }

        return { success: true, data: mappedAkun }
    } catch (error) {
        await logSistem("ERROR", "CREDIT_CARD", "Gagal mengambil detail kartu kredit", (error as Error).stack)
        return { success: false, error: "Gagal mengambil detail kartu kredit" }
    }
}
```

## File: src\app\actions\currency.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { SUPPORTED_CURRENCIES, DEFAULT_RATES, getCurrencyInfo } from "@/lib/currency"

// ============================================
// MULTI-CURRENCY SUPPORT
// ============================================

// Helper untuk format currency (internal use only)
function formatCurrencyHelper(nominal: number, kode: string = "IDR"): string {
    const currency = getCurrencyInfo(kode)
    if (kode === "IDR") {
        return `Rp ${nominal.toLocaleString("id-ID")}`
    }
    const formatted = nominal.toLocaleString("en-US", {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    })
    return `${currency?.simbol || kode} ${formatted}`
}

// Ambil semua currency rates
export async function getCurrencyRates() {
    try {
        const rates = await prisma.currencyRate.findMany({
            where: { kodeTujuan: "IDR" },
            orderBy: { kodeAsal: "asc" }
        })

        // Jika tidak ada rates, buat default rates
        if (rates.length === 0) {
            await initializeDefaultRates()
            return getCurrencyRates()
        }

        return { success: true, data: rates }
    } catch (error) {
        return { success: false, data: [] }
    }
}

// Initialize default rates
async function initializeDefaultRates() {
    try {
        for (const [kode, rate] of Object.entries(DEFAULT_RATES)) {
            await prisma.currencyRate.upsert({
                where: {
                    kodeAsal_kodeTujuan: {
                        kodeAsal: kode,
                        kodeTujuan: "IDR"
                    }
                },
                update: { rate },
                create: {
                    kodeAsal: kode,
                    kodeTujuan: "IDR",
                    rate,
                    sumber: "default"
                }
            })
        }
        await logSistem("INFO", "CURRENCY", "Default rates initialized")
    } catch (error) {
        console.error("Error initializing default rates:", error)
    }
}

// Fetch rates dari CurrencyApi.net
export async function fetchLiveRates(apiKey: string) {
    try {
        const response = await fetch(
            `https://currencyapi.net/api/v1/rates?key=${apiKey}&base=USD&output=JSON`,
            { next: { revalidate: 3600 } } // Cache 1 jam
        )

        if (!response.ok) {
            throw new Error("API request failed")
        }

        const data = await response.json()

        if (!data.valid) {
            throw new Error("Invalid API response")
        }

        // Konversi rates ke IDR base
        // API memberikan rate berdasarkan USD, kita perlu convert ke IDR
        const usdToIdr = data.rates.IDR || 15800

        // Update semua rates ke database
        for (const currency of SUPPORTED_CURRENCIES) {
            if (currency.kode === "IDR") continue

            let rateToIDR: number
            if (currency.kode === "USD") {
                rateToIDR = usdToIdr
            } else {
                // 1 [CURRENCY] = x USD, jadi 1 [CURRENCY] = x * usdToIdr IDR
                const currencyToUsd = 1 / (data.rates[currency.kode] || 1)
                rateToIDR = currencyToUsd * usdToIdr
            }

            await prisma.currencyRate.upsert({
                where: {
                    kodeAsal_kodeTujuan: {
                        kodeAsal: currency.kode,
                        kodeTujuan: "IDR"
                    }
                },
                update: {
                    rate: Math.round(rateToIDR * 100) / 100,
                    tanggalUpdate: new Date(),
                    sumber: "api"
                },
                create: {
                    kodeAsal: currency.kode,
                    kodeTujuan: "IDR",
                    rate: Math.round(rateToIDR * 100) / 100,
                    sumber: "api"
                }
            })
        }

        await logSistem("INFO", "CURRENCY", `Live rates updated from API (${Object.keys(data.rates).length} currencies)`)
        revalidatePath("/pengaturan")

        return { success: true, message: "Rates berhasil diperbarui dari API" }
    } catch (error) {
        await logSistem("ERROR", "CURRENCY", "Gagal fetch live rates", (error as Error).message)
        return { success: false, error: "Gagal mengambil rates dari API: " + (error as Error).message }
    }
}

// Update rate manual
export async function updateCurrencyRate(kodeAsal: string, rate: number) {
    try {
        const updated = await prisma.currencyRate.upsert({
            where: {
                kodeAsal_kodeTujuan: {
                    kodeAsal,
                    kodeTujuan: "IDR"
                }
            },
            update: {
                rate,
                tanggalUpdate: new Date(),
                sumber: "manual"
            },
            create: {
                kodeAsal,
                kodeTujuan: "IDR",
                rate,
                sumber: "manual"
            }
        })

        await logSistem("INFO", "CURRENCY", `Rate updated: 1 ${kodeAsal} = Rp ${rate}`)
        revalidatePath("/pengaturan")

        return { success: true, data: updated }
    } catch (error) {
        return { success: false, error: "Gagal update rate" }
    }
}

// Konversi mata uang ke IDR dengan opsi biaya bank
export async function convertToIDR(
    nominal: number,
    dariKode: string,
    biayaAdminPersen: number = 0 // Biaya admin bank (0-5%)
): Promise<number> {
    if (dariKode === "IDR") return nominal

    try {
        const rate = await prisma.currencyRate.findUnique({
            where: {
                kodeAsal_kodeTujuan: {
                    kodeAsal: dariKode,
                    kodeTujuan: "IDR"
                }
            }
        })

        let baseAmount: number
        if (rate) {
            baseAmount = nominal * rate.rate
        } else if (DEFAULT_RATES[dariKode]) {
            baseAmount = nominal * DEFAULT_RATES[dariKode]
        } else {
            baseAmount = nominal
        }

        // Terapkan potongan biaya admin bank (biasanya bank ambil 1-3%)
        const potonganAdmin = baseAmount * (biayaAdminPersen / 100)
        return baseAmount - potonganAdmin

    } catch (error) {
        return nominal
    }
}

// Konversi dari IDR ke mata uang lain
export async function convertFromIDR(nominal: number, keKode: string): Promise<number> {
    if (keKode === "IDR") return nominal

    try {
        const rate = await prisma.currencyRate.findUnique({
            where: {
                kodeAsal_kodeTujuan: {
                    kodeAsal: keKode,
                    kodeTujuan: "IDR"
                }
            }
        })

        if (rate) {
            return nominal / rate.rate
        }

        // Fallback ke default rate
        if (DEFAULT_RATES[keKode]) {
            return nominal / DEFAULT_RATES[keKode]
        }

        return nominal
    } catch (error) {
        return nominal
    }
}

// Simpan konversi transaksi dengan biaya bank
export async function createTransactionWithCurrency(
    data: {
        deskripsi: string
        nominalAsli: number
        mataUangAsal: string
        kategori: string
        tipeTransaksi: "KELUAR" | "MASUK"
        akunId: string
        tanggal?: Date
        biayaAdminPersen?: number // Biaya admin bank (optional)
        biayaAdminFlat?: number   // Biaya admin flat (optional, dalam IDR)
    }
) {
    try {
        const biayaAdminPersen = data.biayaAdminPersen || 0
        const biayaAdminFlat = data.biayaAdminFlat || 0

        // Konversi ke IDR dengan potongan biaya admin
        let nominalIDR = await convertToIDR(data.nominalAsli, data.mataUangAsal, biayaAdminPersen)

        // Kurangi biaya admin flat
        nominalIDR = nominalIDR - biayaAdminFlat

        // Cari akun kategori
        const kategoriAkun = await prisma.akun.findFirst({
            where: {
                nama: data.tipeTransaksi === "KELUAR"
                    ? `[EXPENSE] ${data.kategori}`
                    : `[INCOME] ${data.kategori}`
            }
        })

        if (!kategoriAkun) {
            return { success: false, error: "Kategori tidak ditemukan" }
        }

        // Format catatan biaya
        const originalFormatted = formatCurrencyHelper(data.nominalAsli, data.mataUangAsal)
        let catatan = `Original: ${originalFormatted}  Rp ${nominalIDR.toLocaleString("id-ID")}`
        if (biayaAdminPersen > 0 || biayaAdminFlat > 0) {
            catatan += ` (Biaya: ${biayaAdminPersen}% + Rp ${biayaAdminFlat.toLocaleString("id-ID")})`
        }

        // Buat transaksi
        const transaksi = await prisma.transaksi.create({
            data: {
                tanggal: data.tanggal || new Date(),
                deskripsi: `${data.deskripsi} (${originalFormatted})`,
                nominal: nominalIDR,
                kategori: data.kategori,
                debitAkunId: data.tipeTransaksi === "KELUAR" ? kategoriAkun.id : data.akunId,
                kreditAkunId: data.tipeTransaksi === "KELUAR" ? data.akunId : kategoriAkun.id,
                catatan,
                idempotencyKey: `currency-${Date.now()}`
            }
        })

        // Update saldo
        if (data.tipeTransaksi === "KELUAR") {
            await prisma.akun.update({
                where: { id: data.akunId },
                data: { saldoSekarang: { decrement: nominalIDR } }
            })
        } else {
            await prisma.akun.update({
                where: { id: data.akunId },
                data: { saldoSekarang: { increment: nominalIDR } }
... (truncated)
```

## File: src\app\actions\debug-automation.ts
```typescript
"use server"

import prisma from "@/lib/prisma"

// Debug function to check automation status
export async function debugAutomationStatus() {
    try {
        const today = new Date()

        // Get all Bank/E-Wallet accounts
        const accounts = await prisma.akun.findMany({
            where: {
                tipe: { in: ['BANK', 'E_WALLET'] }
            },
            select: {
                id: true,
                nama: true,
                tipe: true,
                biayaAdminAktif: true,
                biayaAdminNominal: true,
                biayaAdminPola: true,
                biayaAdminTanggal: true,
                lastAdminChargeDate: true,
                bungaAktif: true,
                bungaTiers: true,
                lastInterestCreditDate: true,
            }
        })

        const currentMonthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`

        const analysis = accounts.map(akun => {
            const lastChargeStr = akun.lastAdminChargeDate
                ? `${akun.lastAdminChargeDate.getFullYear()}-${String(akun.lastAdminChargeDate.getMonth() + 1).padStart(2, '0')}`
                : null

            const lastInterestStr = akun.lastInterestCreditDate
                ? `${akun.lastInterestCreditDate.getFullYear()}-${String(akun.lastInterestCreditDate.getMonth() + 1).padStart(2, '0')}`
                : null

            return {
                nama: akun.nama,
                tipe: akun.tipe,
                adminFee: {
                    aktif: akun.biayaAdminAktif,
                    nominal: akun.biayaAdminNominal,
                    pola: akun.biayaAdminPola,
                    tanggal: akun.biayaAdminTanggal,
                    lastCharged: lastChargeStr,
                    alreadyChargedThisMonth: lastChargeStr === currentMonthStr,
                    willProcess: akun.biayaAdminAktif && akun.biayaAdminNominal && lastChargeStr !== currentMonthStr
                },
                interest: {
                    aktif: akun.bungaAktif,
                    hasTiers: !!akun.bungaTiers,
                    lastCredited: lastInterestStr,
                }
            }
        })

        // Get last 10 automation logs
        const logs = await prisma.logSistem.findMany({
            where: {
                modul: "AUTOMASI"
            },
            orderBy: { createdAt: 'desc' },
            take: 10
        })

        return {
            success: true,
            currentMonth: currentMonthStr,
            totalAccounts: accounts.length,
            withAdminFeeActive: accounts.filter(a => a.biayaAdminAktif).length,
            withInterestActive: accounts.filter(a => a.bungaAktif).length,
            accounts: analysis,
            recentLogs: logs.map(l => ({
                level: l.level,
                pesan: l.pesan,
                createdAt: l.createdAt
            }))
        }
    } catch (error: any) {
        return { success: false, error: error.message }
    }
}

```

## File: src\app\actions\debug-quick.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { calculateNextBillingDate } from "@/lib/template-utils"

// Quick debug to understand why 0 accounts are processed
export async function quickDebugAdminFee() {
    const today = new Date()
    const currentMonthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`

    // Step 1: Get ALL Bank/E-Wallet accounts
    const allAccounts = await prisma.akun.findMany({
        where: {
            tipe: { in: ['BANK', 'E_WALLET'] }
        },
        select: {
            id: true,
            nama: true,
            tipe: true,
            biayaAdminAktif: true,
            biayaAdminNominal: true,
            biayaAdminPola: true,
            biayaAdminTanggal: true,
            lastAdminChargeDate: true,
        }
    })

    // Step 2: Filter accounts with biayaAdminAktif = true
    const activeAccounts = allAccounts.filter(a => a.biayaAdminAktif)

    // Step 3: Check each active account
    const analysis = activeAccounts.map(akun => {
        const billingDate = calculateNextBillingDate(
            akun.biayaAdminPola || 'FIXED_DATE',
            akun.biayaAdminTanggal || 1,
            new Date(today.getFullYear(), today.getMonth(), 1)
        )

        const lastChargeStr = akun.lastAdminChargeDate
            ? `${akun.lastAdminChargeDate.getFullYear()}-${String(akun.lastAdminChargeDate.getMonth() + 1).padStart(2, '0')}`
            : null

        const issues: string[] = []
        if (!akun.biayaAdminNominal) issues.push("Tidak ada nominal")
        if (billingDate > today) issues.push(`Tanggal belum tiba (${billingDate.toLocaleDateString('id-ID')})`)
        if (lastChargeStr === currentMonthStr) issues.push("Sudah diproses bulan ini")

        return {
            nama: akun.nama,
            nominal: akun.biayaAdminNominal,
            pola: akun.biayaAdminPola,
            tanggalPola: akun.biayaAdminTanggal,
            calculatedBillingDate: billingDate.toLocaleDateString('id-ID'),
            lastCharged: lastChargeStr,
            willProcess: issues.length === 0,
            issues
        }
    })

    const recent5Logs = await prisma.logSistem.findMany({
        where: { modul: "AUTOMASI" },
        orderBy: { createdAt: 'desc' },
        take: 5
    })

    return {
        today: today.toISOString(),
        currentMonth: currentMonthStr,
        totalBankEWallet: allAccounts.length,
        withAdminFeeActive: activeAccounts.length,
        willBeProcessed: analysis.filter(a => a.willProcess).length,
        accounts: analysis,
        recentLogs: recent5Logs
    }
}

```

## File: src\app\actions\debug.ts
```typescript
"use server"

import prisma from "@/lib/prisma"

const PAGE_SIZE = 50 // Limit per halaman untuk keamanan

export async function getAkunData(page: number = 1) {
    const skip = (page - 1) * PAGE_SIZE

    const [data, total] = await Promise.all([
        prisma.akun.findMany({
            take: PAGE_SIZE,
            skip,
            orderBy: { createdAt: 'desc' }
        }),
        prisma.akun.count()
    ])

    return {
        data,
        pagination: {
            page,
            pageSize: PAGE_SIZE,
            total,
            totalPages: Math.ceil(total / PAGE_SIZE)
        }
    }
}

export async function getTransaksiData(page: number = 1) {
    const skip = (page - 1) * PAGE_SIZE

    const [data, total] = await Promise.all([
        prisma.transaksi.findMany({
            take: PAGE_SIZE,
            skip,
            orderBy: { tanggal: 'desc' },
            include: {
                debitAkun: { select: { nama: true, tipe: true } },
                kreditAkun: { select: { nama: true, tipe: true } }
            }
        }),
        prisma.transaksi.count()
    ])

    return {
        data,
        pagination: {
            page,
            pageSize: PAGE_SIZE,
            total,
            totalPages: Math.ceil(total / PAGE_SIZE)
        }
    }
}

export async function getRecurringData(page: number = 1) {
    const skip = (page - 1) * PAGE_SIZE

    const [data, total] = await Promise.all([
        prisma.recurringTransaction.findMany({
            take: PAGE_SIZE,
            skip,
            orderBy: { createdAt: 'desc' }
        }),
        prisma.recurringTransaction.count()
    ])

    return {
        data,
        pagination: {
            page,
            pageSize: PAGE_SIZE,
            total,
            totalPages: Math.ceil(total / PAGE_SIZE)
        }
    }
}

export async function getLogData(page: number = 1, module?: string) {
    const skip = (page - 1) * PAGE_SIZE

    const where = module ? { modul: module } : {}

    const [data, total] = await Promise.all([
        prisma.logSistem.findMany({
            where,
            take: PAGE_SIZE,
            skip,
            orderBy: { createdAt: 'desc' }
        }),
        prisma.logSistem.count({ where })
    ])

    return {
        data,
        pagination: {
            page,
            pageSize: PAGE_SIZE,
            total,
            totalPages: Math.ceil(total / PAGE_SIZE)
        }
    }
}

export async function getAppSettingsData(page: number = 1) {
    const skip = (page - 1) * PAGE_SIZE

    const [data, total] = await Promise.all([
        prisma.appSetting.findMany({
            take: PAGE_SIZE,
            skip,
            orderBy: { kunci: 'asc' }
        }),
        prisma.appSetting.count()
    ])

    return {
        data,
        pagination: {
            page,
            pageSize: PAGE_SIZE,
            total,
            totalPages: Math.ceil(total / PAGE_SIZE)
        }
    }
}

export async function getDatabaseStats() {
    const USER_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

    const [akunTotal, akunUser, transaksiCount, recurringCount, logCount, settingCount] = await Promise.all([
        prisma.akun.count(),
        prisma.akun.count({ where: { tipe: { in: USER_TYPES } } }),
        prisma.transaksi.count(),
        prisma.recurringTransaction.count(),
        prisma.logSistem.count(),
        prisma.appSetting.count()
    ])

    return {
        akun: akunTotal,
        akunUser: akunUser,
        akunInternal: akunTotal - akunUser,
        transaksi: transaksiCount,
        recurring: recurringCount,
        log: logCount,
        setting: settingCount
    }
}

export async function pruneOldLogs(days: number = 30) {
    try {
        const thresholdDate = new Date()
        thresholdDate.setDate(thresholdDate.getDate() - days)

        const result = await prisma.logSistem.deleteMany({
            where: {
                createdAt: {
                    lt: thresholdDate
                }
            }
        })

        if (result.count > 0) {
            console.log(`[SYSTEM] Pruned ${result.count} old system logs (older than ${days} days)`)
        }

        return { success: true, count: result.count }
    } catch (error) {
        console.error("Failed to prune logs:", error)
        return { success: false, error: "Gagal menghapus log lama" }
    }
}

```

## File: src\app\actions\installment.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

/**
 * Get all active installment templates
 */
export async function getInstallmentTemplates() {
    try {
        const templates = await prisma.installmentTemplate.findMany({
            where: { isActive: true },
            orderBy: [
                { bankName: "asc" },
                { nama: "asc" }
            ]
        })

        return { success: true, data: templates }
    } catch (error) {
        await logSistem("ERROR", "INSTALLMENT", "Gagal mengambil template cicilan", (error as Error).stack)
        return { success: false, data: [], error: "Gagal mengambil template cicilan" }
    }
}

/**
 * Get templates by bank name
 */
export async function getTemplatesByBank(bankName: string) {
    try {
        const templates = await prisma.installmentTemplate.findMany({
            where: {
                isActive: true,
                bankName: {
                    contains: bankName
                }
            }
        })

        return { success: true, data: templates }
    } catch (error) {
        await logSistem("ERROR", "INSTALLMENT", "Gagal mengambil template bank", (error as Error).stack)
        return { success: false, data: [], error: "Gagal mengambil template" }
    }
}

interface ConvertToInstallmentParams {
    transaksiId: string
    tenor: number
    templateId?: string
    adminFeeAmount?: number
    adminFeeType?: "FLAT" | "PERCENTAGE"
}

/**
 * Convert transaction to installment plan
 * Logic (CIMB Niaga style):
 * 1. Cicilan per bulan = Nominal Transaksi / Tenor (TANPA admin fee)
 * 2. Admin fee = Transaksi terpisah (one-time)
 * 3. Original transaction tetap (sudah mengurangi limit), hanya tandai sebagai converted
 * 4. Buat RencanaCicilan untuk tracking pembayaran
 */
export async function convertTransactionToInstallment(params: ConvertToInstallmentParams) {
    const { transaksiId, tenor, templateId, adminFeeAmount, adminFeeType } = params

    try {
        // Validate inputs
        if (!transaksiId || !tenor || tenor < 1) {
            return { success: false, error: "Data tidak valid" }
        }

        // Get transaction details
        const transaksi = await prisma.transaksi.findUnique({
            where: { id: transaksiId },
            include: {
                kreditAkun: true,
                debitAkun: true
            }
        })

        if (!transaksi) {
            return { success: false, error: "Transaksi tidak ditemukan" }
        }

        // Validate transaction not already converted
        if (transaksi.convertedToInstallment) {
            return { success: false, error: "Transaksi sudah dikonversi ke cicilan" }
        }

        // Validate transaction is from credit card
        if (transaksi.kreditAkun.tipe !== "CREDIT_CARD") {
            return { success: false, error: "Transaksi harus dari kartu kredit" }
        }

        const nominalFloat = Money.toFloat(Number(transaksi.nominal))

        // Check minimum installment amount if set
        const minAmount = transaksi.kreditAkun.minInstallmentAmount ? Money.toFloat(Number(transaksi.kreditAkun.minInstallmentAmount)) : null
        if (minAmount && nominalFloat < minAmount) {
            return {
                success: false,
                error: `Nominal minimal untuk konversi cicilan adalah Rp ${minAmount.toLocaleString('id-ID')}`
            }
        }

        // Load template if provided
        let template = null
        let finalAdminFee = adminFeeAmount || 0
        let finalAdminFeeType = adminFeeType || "FLAT"
        let installmentType = "REGULAR"

        if (templateId) {
            template = await prisma.installmentTemplate.findUnique({
                where: { id: templateId }
            })

            if (template) {
                finalAdminFeeType = template.adminFeeType as "FLAT" | "PERCENTAGE"
                finalAdminFee = template.adminFeeAmount || 0
                installmentType = template.interestRate === 0 ? "ZERO_PERCENT" : "REGULAR"
            }
        }

        // Calculate admin fee
        let adminFeeNominal = 0
        if (finalAdminFeeType === "PERCENTAGE") {
            adminFeeNominal = nominalFloat * (finalAdminFee / 100)
        } else {
            adminFeeNominal = finalAdminFee
        }

        // ** KEY DIFFERENCE ** 
        // Cicilan per bulan = Nominal transaksi / Tenor (TANPA admin fee)
        // Admin fee adalah transaksi terpisah, tidak termasuk dalam cicilan bulanan
        const nominalPerBulan = Math.ceil(nominalFloat / tenor)

        // Get or create expense account for cicilan
        const namaAkunDebit = "[EXPENSE] Cicilan"
        let akunDebit = await prisma.akun.findFirst({
            where: { nama: namaAkunDebit }
        })

        if (!akunDebit) {
            akunDebit = await prisma.akun.create({
                data: {
                    nama: namaAkunDebit,
                    tipe: "EXPENSE",
                    saldoAwal: BigInt(0),
                    saldoSekarang: BigInt(0),
                }
            })
        }

        // Prepare BigInt values
        const nominalPerBulanInt = BigInt(Money.fromFloat(nominalPerBulan))
        const adminFeeNominalInt = BigInt(Money.fromFloat(adminFeeNominal))

        // Atomic transaction
        const result = await prisma.$transaction(async (tx) => {
            // 1. Create RencanaCicilan
            const cicilan = await tx.rencanaCicilan.create({
                data: {
                    namaProduk: transaksi.deskripsi,
                    totalPokok: transaksi.nominal, // BigInt
                    tenor: tenor,
                    cicilanKe: 1,
                    nominalPerBulan: nominalPerBulanInt,
                    biayaAdmin: adminFeeNominalInt,
                    bungaPersen: template?.interestRate || 0,
                    tanggalJatuhTempo: transaksi.kreditAkun.dueDate || 15,
                    status: "AKTIF",
                    akunKreditId: transaksi.kreditAkunId,
                    akunDebitId: akunDebit!.id,
                    isConvertedFromTx: true,
                    originalTxId: transaksi.id,
                    templateId: templateId || null,
                    adminFeeType: finalAdminFeeType,
                    adminFeeAmount: adminFeeNominal, // Float stored in RencanaCicilan (schema might need update if I missed this?)
                    installmentType: installmentType
                }
            })
            
            // Note: `adminFeeAmount` in RencanaCicilan schema is `Float?`. I did not migrate it to Int because it's metadata/config?
            // "adminFeeAmount Float?" in schema.
            // "biayaAdmin BigInt" in schema.
            // So storing `adminFeeNominal` (float) in `adminFeeAmount` is correct.

            // 2. Mark original transaction as converted (SALDO TIDAK DIUBAH)
            // Transaksi asli tetap valid dan sudah mengurangi limit kartu kredit
            await tx.transaksi.update({
                where: { id: transaksiId },
                data: {
                    convertedToInstallment: true,
                    rencanaCicilanId: cicilan.id
                }
            })

            // 3. TIDAK ada reversal saldo - transaksi asli sudah menghitung utang dengan benar

            // 4. Create admin fee transaction if applicable (transaksi terpisah)
            if (adminFeeNominal > 0) {
                // Get or create biaya admin expense account
                const namaAkunAdmin = "[EXPENSE] Biaya Admin Cicilan"
                let akunAdmin = await tx.akun.findFirst({
                    where: { nama: namaAkunAdmin }
                })

                if (!akunAdmin) {
                    akunAdmin = await tx.akun.create({
                        data: {
                            nama: namaAkunAdmin,
                            tipe: "EXPENSE",
                            saldoAwal: BigInt(0),
                            saldoSekarang: BigInt(0)
                        }
                    })
                }

                // Create admin fee as separate transaction (menambah utang kartu kredit)
                await tx.transaksi.create({
                    data: {
                        deskripsi: `Biaya Admin Cicilan: ${transaksi.deskripsi}`,
                        nominal: adminFeeNominalInt,
                        kategori: "Biaya Admin",
                        debitAkunId: akunAdmin.id,
                        kreditAkunId: transaksi.kreditAkunId,
                        tanggal: new Date(),
                        catatan: `Biaya admin konversi ${tenor} bulan (Template: ${template?.nama || 'Manual'})`,
                        rencanaCicilanId: cicilan.id
                    }
                })

                // Update saldo for admin fee (menambah pengeluaran dan utang)
                await tx.akun.update({
                    where: { id: akunAdmin.id },
                    data: { saldoSekarang: { increment: adminFeeNominalInt } }
                })
                await tx.akun.update({
                    where: { id: transaksi.kreditAkunId },
                    data: { saldoSekarang: { decrement: adminFeeNominalInt } }
                })
            }

            return cicilan
        })

        await logSistem("INFO", "INSTALLMENT",
            `Transaksi dikonversi ke cicilan: ${transaksi.deskripsi} (${tenor} bulan  Rp ${nominalPerBulan.toLocaleString('id-ID')}, admin Rp ${adminFeeNominal.toLocaleString('id-ID')})`)

        revalidatePath("/transaksi")
        revalidatePath("/cicilan")
        revalidatePath("/akun")
        revalidatePath(`/akun/${transaksi.kreditAkunId}`)
        revalidatePath("/")

        const mappedResult = {
            ...result,
            totalPokok: Money.toFloat(Number(result.totalPokok)),
            nominalPerBulan: Money.t
... (truncated)
```

## File: src\app\actions\laporan.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { Money } from "@/lib/money"

const USER_ACCOUNT_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

interface RingkasanBulanan {
    bulan: number
    tahun: number
    bulanNama: string
    totalPemasukan: number
    totalPengeluaran: number
    selisih: number
    pengeluaranPerKategori: { kategori: string; total: number; persentase: number }[]
    pemasukanPerKategori: { kategori: string; total: number; persentase: number }[]
    transaksiTerbesar: { deskripsi: string; nominal: number; kategori: string; tanggal: Date }[]
    rataRataHarian: number
    jumlahTransaksi: number
}

export async function getRingkasanBulanan(bulan: number, tahun: number): Promise<RingkasanBulanan> {
    try {
        const namaBulan = [
            'Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni',
            'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'
        ]

        const startOfMonth = new Date(tahun, bulan - 1, 1)
        const endOfMonth = new Date(tahun, bulan, 0, 23, 59, 59)
        const daysInMonth = new Date(tahun, bulan, 0).getDate()

        // Ambil semua transaksi bulan ini
        const transaksi = await prisma.transaksi.findMany({
            where: {
                tanggal: { gte: startOfMonth, lte: endOfMonth }
            },
            include: {
                debitAkun: true,
                kreditAkun: true,
            },
            orderBy: { nominal: 'desc' }
        })

        // Hitung pemasukan dan pengeluaran
        let totalPemasukan = 0
        let totalPengeluaran = 0
        const pengeluaranMap = new Map<string, number>()
        const pemasukanMap = new Map<string, number>()

        for (const tx of transaksi) {
            const isExpense = tx.debitAkun?.tipe === "EXPENSE"
            const isIncome = tx.kreditAkun?.tipe === "INCOME"
            const nominal = Money.toFloat(Number(tx.nominal))

            if (isExpense) {
                totalPengeluaran += nominal
                const existing = pengeluaranMap.get(tx.kategori) || 0
                pengeluaranMap.set(tx.kategori, existing + nominal)
            } else if (isIncome) {
                totalPemasukan += nominal
                const existing = pemasukanMap.get(tx.kategori) || 0
                pemasukanMap.set(tx.kategori, existing + nominal)
            }
        }

        // Convert to array with percentage
        const pengeluaranPerKategori = Array.from(pengeluaranMap.entries())
            .map(([kategori, total]) => ({
                kategori,
                total,
                persentase: totalPengeluaran > 0 ? (total / totalPengeluaran) * 100 : 0
            }))
            .sort((a, b) => b.total - a.total)

        const pemasukanPerKategori = Array.from(pemasukanMap.entries())
            .map(([kategori, total]) => ({
                kategori,
                total,
                persentase: totalPemasukan > 0 ? (total / totalPemasukan) * 100 : 0
            }))
            .sort((a, b) => b.total - a.total)

        // Transaksi terbesar (pengeluaran)
        const transaksiTerbesar = transaksi
            .filter(tx => tx.debitAkun?.tipe === "EXPENSE")
            .slice(0, 5)
            .map(tx => ({
                deskripsi: tx.deskripsi,
                nominal: Money.toFloat(Number(tx.nominal)),
                kategori: tx.kategori,
                tanggal: tx.tanggal
            }))

        return {
            bulan,
            tahun,
            bulanNama: namaBulan[bulan - 1],
            totalPemasukan,
            totalPengeluaran,
            selisih: totalPemasukan - totalPengeluaran,
            pengeluaranPerKategori,
            pemasukanPerKategori,
            transaksiTerbesar,
            rataRataHarian: totalPengeluaran / daysInMonth,
            jumlahTransaksi: transaksi.length
        }
    } catch (error) {
        await logSistem("ERROR", "LAPORAN", "Gagal mengambil ringkasan bulanan", (error as Error).stack)
        throw new Error("Gagal mengambil ringkasan bulanan")
    }
}

export async function getAvailableMonths(): Promise<{ bulan: number; tahun: number }[]> {
    try {
        const transaksi = await prisma.transaksi.findMany({
            select: { tanggal: true },
            orderBy: { tanggal: 'desc' }
        })

        const monthSet = new Set<string>()
        const result: { bulan: number; tahun: number }[] = []

        for (const tx of transaksi) {
            const key = `${tx.tanggal.getFullYear()}-${tx.tanggal.getMonth() + 1}`
            if (!monthSet.has(key)) {
                monthSet.add(key)
                result.push({
                    bulan: tx.tanggal.getMonth() + 1,
                    tahun: tx.tanggal.getFullYear()
                })
            }
        }

        // Tambahkan bulan ini jika belum ada
        const now = new Date()
        const currentKey = `${now.getFullYear()}-${now.getMonth() + 1}`
        if (!monthSet.has(currentKey)) {
            result.unshift({
                bulan: now.getMonth() + 1,
                tahun: now.getFullYear()
            })
        }

        return result
    } catch (error) {
        return [{ bulan: new Date().getMonth() + 1, tahun: new Date().getFullYear() }]
    }
}

```

## File: src\app\actions\networth.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { Money } from "@/lib/money"

// ============================================
// NET WORTH TRACKING
// ============================================

const USER_ACCOUNT_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

export interface NetWorthData {
    tanggal: Date
    totalAset: number
    totalHutang: number
    netWorth: number
    breakdown: Record<string, number>
}

// Hitung net worth saat ini
export async function calculateCurrentNetWorth(): Promise<NetWorthData> {
    try {
        const akuns = await prisma.akun.findMany({
            where: { tipe: { in: USER_ACCOUNT_TYPES } }
        })

        // Hitung total per tipe
        const breakdown: Record<string, number> = {}
        let totalAset = 0
        let totalHutang = 0

        for (const akun of akuns) {
            if (!breakdown[akun.tipe]) {
                breakdown[akun.tipe] = 0
            }
            const saldo = Money.toFloat(Number(akun.saldoSekarang))
            breakdown[akun.tipe] += saldo

            if (akun.tipe === "CREDIT_CARD") {
                // Kartu kredit: saldo negatif = hutang
                if (saldo < 0) {
                    totalHutang += Math.abs(saldo)
                }
            } else {
                // Aset normal
                if (saldo > 0) {
                    totalAset += saldo
                }
            }
        }

        // Tambahkan hutang cicilan aktif
        const cicilanAktif = await prisma.rencanaCicilan.findMany({
            where: { status: "AKTIF" }
        })

        for (const cicilan of cicilanAktif) {
            const sisaBulan = cicilan.tenor - cicilan.cicilanKe + 1
            const nominal = Money.toFloat(Number(cicilan.nominalPerBulan))
            const sisaHutang = nominal * sisaBulan
            totalHutang += sisaHutang
        }

        const netWorth = totalAset - totalHutang

        return {
            tanggal: new Date(),
            totalAset,
            totalHutang,
            netWorth,
            breakdown
        }
    } catch (error) {
        console.error("Error calculating net worth:", error)
        return {
            tanggal: new Date(),
            totalAset: 0,
            totalHutang: 0,
            netWorth: 0,
            breakdown: {}
        }
    }
}

// Simpan snapshot net worth (bisa dipanggil daily via cron atau real-time)
export async function saveNetWorthSnapshot() {
    try {
        const data = await calculateCurrentNetWorth()

        const startOfDay = new Date()
        startOfDay.setHours(0, 0, 0, 0)
        
        const endOfDay = new Date()
        endOfDay.setHours(23, 59, 59, 999)

        // Cari snapshot hari ini untuk di-upsert
        const existingSnapshot = await prisma.netWorthSnapshot.findFirst({
            where: {
                tanggal: {
                    gte: startOfDay,
                    lte: endOfDay
                }
            }
        })

        let snapshot
        if (existingSnapshot) {
            snapshot = await prisma.netWorthSnapshot.update({
                where: { id: existingSnapshot.id },
                data: {
                    totalAset: data.totalAset,
                    totalHutang: data.totalHutang,
                    netWorth: data.netWorth,
                    breakdown: JSON.stringify(data.breakdown),
                    tanggal: new Date() // Refresh timestamp ke detik terbaru
                }
            })
        } else {
            snapshot = await prisma.netWorthSnapshot.create({
                data: {
                    tanggal: data.tanggal,
                    totalAset: data.totalAset,
                    totalHutang: data.totalHutang,
                    netWorth: data.netWorth,
                    breakdown: JSON.stringify(data.breakdown)
                }
            })
        }

        await logSistem("INFO", "NETWORTH", `Snapshot ${existingSnapshot ? 'diperbarui' : 'disimpan'}: ${data.netWorth}`)
        return { success: true, data: snapshot }
    } catch (error) {
        await logSistem("ERROR", "NETWORTH", "Gagal menyimpan snapshot", (error as Error).stack)
        return { success: false, error: "Gagal menyimpan snapshot" }
    }
}

// Ambil histori net worth untuk chart
export async function getNetWorthHistory(days: number = 30) {
    try {
        const startDate = new Date()
        startDate.setDate(startDate.getDate() - days)

        let snapshots = await prisma.netWorthSnapshot.findMany({
            where: {
                tanggal: { gte: startDate }
            },
            orderBy: { tanggal: "asc" }
        })

        // Jika tidak ada snapshot, buat satu untuk hari ini
        if (snapshots.length === 0) {
            await saveNetWorthSnapshot()
            snapshots = await prisma.netWorthSnapshot.findMany({
                where: {
                    tanggal: { gte: startDate }
                },
                orderBy: { tanggal: "asc" }
            })
        }

        // Parse breakdown JSON
        const parsed = snapshots.map(s => ({
            ...s,
            breakdown: s.breakdown ? JSON.parse(s.breakdown) : {}
        }))

        return { success: true, data: parsed }
    } catch (error) {
        return { success: false, data: [] }
    }
}

// Ambil perubahan net worth
export async function getNetWorthChange() {
    try {
        const current = await calculateCurrentNetWorth()

        // Ambil snapshot 30 hari lalu
        const thirtyDaysAgo = new Date()
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30)

        const oldSnapshot = await prisma.netWorthSnapshot.findFirst({
            where: {
                tanggal: { lte: thirtyDaysAgo }
            },
            orderBy: { tanggal: "desc" }
        })

        const change = oldSnapshot ? current.netWorth - oldSnapshot.netWorth : 0
        const changePercent = oldSnapshot && oldSnapshot.netWorth !== 0
            ? ((current.netWorth - oldSnapshot.netWorth) / Math.abs(oldSnapshot.netWorth)) * 100
            : 0

        return {
            success: true,
            data: {
                current: current.netWorth,
                previous: oldSnapshot?.netWorth || current.netWorth,
                change,
                changePercent: Math.round(changePercent * 10) / 10,
                totalAset: current.totalAset,
                totalHutang: current.totalHutang,
                breakdown: current.breakdown
            }
        }
    } catch (error) {
        return {
            success: false,
            data: {
                current: 0,
                previous: 0,
                change: 0,
                changePercent: 0,
                totalAset: 0,
                totalHutang: 0,
                breakdown: {}
            }
        }
    }
}

```

## File: src\app\actions\recurring-admin.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { calculateNextBillingDate, getApplicableInterestRate, TierBunga } from "@/lib/template-utils"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

function safeRevalidate(path: string) {
  try { revalidatePath(path) } catch { }
}

export async function getMinimumBalanceForMonth(akunId: string, year: number, month: number) {
  const startTime = performance.now();
  const startDate = new Date(Date.UTC(year, month - 1, 1, 0, 0, 0, 0));
  const endDate = new Date(Date.UTC(year, month, 0, 23, 59, 59, 999));

  const akun = await prisma.akun.findUnique({
    where: { id: akunId },
    select: { createdAt: true, saldoSekarang: true, saldoAwal: true }
  });

  if (!akun) throw new Error("Akun tidak ditemukan");
  if (akun.createdAt > endDate) return { minBalance: 0, executionTime: performance.now() - startTime, notExists: true };

  const [totalDebit, totalKredit] = await Promise.all([
    prisma.transaksi.aggregate({ where: { tanggal: { gte: startDate }, debitAkunId: akunId }, _sum: { nominal: true } }),
    prisma.transaksi.aggregate({ where: { tanggal: { gte: startDate }, kreditAkunId: akunId }, _sum: { nominal: true } })
  ]);

  const debitSum = totalDebit._sum.nominal ?? BigInt(0)
  const kreditSum = totalKredit._sum.nominal ?? BigInt(0)
  const sumMutations = debitSum - kreditSum
  
  let runningBalance = akun.saldoSekarang - sumMutations;

  if (akun.createdAt > startDate && akun.createdAt <= endDate) {
    runningBalance = akun.saldoAwal;
  }

  let minBalance = runningBalance;
  const transactions = await prisma.transaksi.findMany({
    where: { tanggal: { gte: startDate, lte: endDate }, OR: [{ debitAkunId: akunId }, { kreditAkunId: akunId }] },
    orderBy: { tanggal: 'asc' }
  });

  for (const tx of transactions) {
    if (tx.debitAkunId === akunId) runningBalance += tx.nominal;
    else runningBalance -= tx.nominal;
    if (runningBalance < minBalance) minBalance = runningBalance;
  }

  return { minBalance: Money.toFloat(Number(minBalance)), executionTime: performance.now() - startTime };
}

export async function processMonthlyAdminFees(dryRun: boolean = false) {
  try {
    const today = new Date()
    const currentMonthStr = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`

    // Get accounts with biayaAdminAktif=true (Bank, E-Wallet only - NOT Credit Card)
    // Credit Card has its own billing system via statement
    const akunList = await prisma.akun.findMany({
      where: {
        biayaAdminAktif: true,
        tipe: { in: ['BANK', 'E_WALLET'] }
      }
    })

    const processedTransactions = []
    const failedAccounts = []
    const skippedAccounts = []

    for (const akun of akunList) {
      // Skip if no admin fee nominal
      if (!akun.biayaAdminNominal) {
        skippedAccounts.push({ name: akun.nama, reason: "Tidak ada nominal biaya admin" })
        continue
      }

      // Calculate billing date
      const billingDate = calculateNextBillingDate(
        akun.biayaAdminPola || 'FIXED_DATE',
        akun.biayaAdminTanggal || 1,
        new Date(today.getFullYear(), today.getMonth(), 1)
      )

      // Skip if billing date hasn't come yet
      if (billingDate > today) {
        skippedAccounts.push({ name: akun.nama, reason: `Tanggal tagihan belum tiba (${billingDate.toLocaleDateString('id-ID')})` })
        continue
      }

      // Check if already processed this month
      const lastChargeStr = akun.lastAdminChargeDate ?
        `${akun.lastAdminChargeDate.getFullYear()}-${String(akun.lastAdminChargeDate.getMonth() + 1).padStart(2, '0')}` : null

      if (lastChargeStr === currentMonthStr) {
        skippedAccounts.push({ name: akun.nama, reason: "Sudah diproses bulan ini" })
        continue
      }

      const nominal = akun.biayaAdminNominal
      const deskripsi = `Biaya admin bulanan ${akun.nama}`

      if (dryRun) {
        processedTransactions.push({ akunId: akun.id, namaAkun: akun.nama, nominal, tanggal: billingDate })
        continue
      }

      try {
        const nominalSen = BigInt(Money.fromFloat(nominal))

        await prisma.$transaction(async (tx) => {
          let kategoriAkun = await tx.akun.findFirst({ where: { nama: "[EXPENSE] Biaya Admin Bank" } })
          if (!kategoriAkun) kategoriAkun = await tx.akun.create({ data: { nama: "[EXPENSE] Biaya Admin Bank", tipe: "PENGELUARAN", warna: "#ef4444" } })

          const txData = await tx.transaksi.create({
            data: {
              tanggal: billingDate, deskripsi, nominal: nominalSen, kategori: "Biaya Admin Bank",
              debitAkunId: kategoriAkun.id, kreditAkunId: akun.id,
              idempotencyKey: `admin-${akun.id}-${currentMonthStr}`
            }
          })
          await tx.akun.update({ where: { id: akun.id }, data: { saldoSekarang: { decrement: nominalSen }, lastAdminChargeDate: billingDate } })
          processedTransactions.push(txData)
        }, { timeout: 15000 })
      } catch (e: any) {
        failedAccounts.push({ name: akun.nama, error: e.message })
      }
    }

    // Always log the result
    const logMessage = dryRun
      ? `[SIMULASI] Biaya admin: ${processedTransactions.length} akun terdeteksi (dari ${akunList.length} akun aktif)`
      : `Biaya admin diproses: ${processedTransactions.length} berhasil, ${failedAccounts.length} gagal (dari ${akunList.length} akun aktif)`

    await logSistem("INFO", "AUTOMASI", logMessage)

    // Log skipped accounts for debugging if nothing was processed
    if (processedTransactions.length === 0 && skippedAccounts.length > 0) {
      await logSistem("INFO", "AUTOMASI", `Akun di-skip: ${skippedAccounts.map(a => `${a.name} (${a.reason})`).slice(0, 3).join(', ')}${skippedAccounts.length > 3 ? '...' : ''}`)
    }

    safeRevalidate("/")
    safeRevalidate("/pengaturan")

    return { success: true, processed: processedTransactions.length, failed: failedAccounts.length }
  } catch (error: any) {
    await logSistem("ERROR", "AUTOMASI", `Gagal proses biaya admin: ${error.message}`)
    return { success: false, error: error.message }
  }
}

export async function processMonthlyInterest(dryRun: boolean = false) {
  try {
    const today = new Date()
    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1)
    const targetMonthStr = `${lastMonth.getFullYear()}-${String(lastMonth.getMonth() + 1).padStart(2, '0')}`
    const lastMonthEnd = new Date(today.getFullYear(), today.getMonth(), 0)

    const useMinBalanceFlag = await prisma.appSetting.findUnique({ where: { kunci: "USE_MIN_BALANCE_METHOD" } })
    const useMinBalance = useMinBalanceFlag?.nilai === "true"

    // Include Bank and E-Wallet for interest calculation
    const akunList = await prisma.akun.findMany({
      where: {
        tipe: { in: ['BANK', 'E_WALLET'] },
        bungaAktif: true
      }
    })

    const processedTransactions = []
    const skippedAccounts = []
    const failedAccounts = []

    for (const akun of akunList) {
      const lastCreditStr = akun.lastInterestCreditDate ?
        `${akun.lastInterestCreditDate.getFullYear()}-${String(akun.lastInterestCreditDate.getMonth() + 1).padStart(2, '0')}` : null

      if (lastCreditStr === targetMonthStr) {
        skippedAccounts.push({ name: akun.nama, reason: "Sudah dikreditkan bulan ini" })
        continue
      }

      let basisBunga = akun.saldoSekarang
      let methodUsed = "Saldo Akhir"

      if (useMinBalance) {
        const res = await getMinimumBalanceForMonth(akun.id, lastMonth.getFullYear(), lastMonth.getMonth() + 1)
        if (res.notExists) {
          skippedAccounts.push({ name: akun.nama, reason: "Akun belum ada di bulan lalu" })
          continue
        }
        // Min Balance is returned as Float, convert back to BigInt
        const minBalanceBig = BigInt(Money.fromFloat(res.minBalance))
        basisBunga = minBalanceBig > BigInt(0) ? minBalanceBig : BigInt(0)
        methodUsed = "Saldo Terendah"
      }

      const tiers: TierBunga[] = JSON.parse(akun.bungaTiers || "[]")
      const basisBungaFloat = Money.toFloat(Number(basisBunga))
      const bungaPa = getApplicableInterestRate(basisBungaFloat, tiers)

      if (bungaPa <= 0) {
        skippedAccounts.push({ name: akun.nama, reason: "Bunga tidak berlaku untuk saldo ini" })
        continue
      }

      const bungaBersih = Math.floor((basisBungaFloat * (bungaPa / 100) / 12) * 0.8)
      if (bungaBersih < 1) {
        skippedAccounts.push({ name: akun.nama, reason: "Bunga terlalu kecil (< Rp 1)" })
        continue
      }

      if (dryRun) {
        processedTransactions.push({ name: akun.nama, nominal: bungaBersih })
        continue
      }

      try {
        const bungaBersihSen = BigInt(Money.fromFloat(bungaBersih))

        await prisma.$transaction(async (tx) => {
          let kategoriAkun = await tx.akun.findFirst({ where: { nama: "[INCOME] Bunga Tabungan" } })
          if (!kategoriAkun) kategoriAkun = await tx.akun.create({ data: { nama: "[INCOME] Bunga Tabungan", tipe: "PENDAPATAN", warna: "#10b981" } })

          await tx.transaksi.create({
            data: {
              tanggal: lastMonthEnd, deskripsi: `Bunga tabungan ${akun.nama} (${methodUsed})`, nominal: bungaBersihSen, kategori: "Bunga Tabungan",
              debitAkunId: akun.id, kreditAkunId: kategoriAkun.id,
              idempotencyKey: `interest-${akun.id}-${targetMonthStr}`
            }
          })
          await tx.akun.update({ where: { id: akun.id }, data: { saldoSekarang: { increment: bungaBersihSen }, lastInterestCreditDate: lastMonthEnd } })
          processedTransactions.push({ name: akun.nama })
        }, { timeout: 15000 })
      } catch (e: any) {
        failedAccounts.push({ name: akun.nama, error: e.message })
      }
    }

    // Always log the result
    const logMessage = dryRun
      ? `[SIMULASI] Bunga tabungan: ${processedTransactions.le
... (truncated)
```

## File: src\app\actions\recurring.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { saveNetWorthSnapshot } from "@/app/actions/networth"
import { Money } from "@/lib/money"

export interface RecurringTransactionData {
    nama: string
    nominal: number
    kategori: string
    tipeTransaksi: "KELUAR" | "MASUK"
    akunId: string
    frekuensi: "HARIAN" | "MINGGUAN" | "BULANAN" | "TAHUNAN"
    hariDalamBulan?: number // 1-31 untuk bulanan
    hariDalamMinggu?: number // 0-6 untuk mingguan (0=Minggu)
    tanggalSelesai?: Date
}

export async function createRecurringTransaction(data: RecurringTransactionData) {
    try {
        // Validasi
        if (data.nominal <= 0) {
            return { success: false, error: "Nominal harus lebih dari 0" }
        }

        const recurring = await prisma.recurringTransaction.create({
            data: {
                nama: data.nama,
                nominal: data.nominal,
                kategori: data.kategori,
                tipeTransaksi: data.tipeTransaksi,
                akunId: data.akunId,
                frekuensi: data.frekuensi,
                hariDalamBulan: data.hariDalamBulan,
                hariDalamMinggu: data.hariDalamMinggu,
                tanggalSelesai: data.tanggalSelesai,
                aktif: true,
            },
        })

        await logSistem("INFO", "RECURRING", `Transaksi berulang dibuat: ${recurring.nama}`)
        revalidatePath("/recurring")

        return { success: true, data: recurring }
    } catch (error) {
        await logSistem("ERROR", "RECURRING", "Gagal membuat transaksi berulang", (error as Error).stack)
        return { success: false, error: "Gagal membuat transaksi berulang" }
    }
}

export async function getRecurringTransactions() {
    try {
        const recurring = await prisma.recurringTransaction.findMany({
            orderBy: { createdAt: "desc" }
        })
        return { success: true, data: recurring }
    } catch (error) {
        return { success: false, data: [], error: "Gagal mengambil data" }
    }
}

export async function toggleRecurringTransaction(id: string, aktif: boolean) {
    try {
        const recurring = await prisma.recurringTransaction.update({
            where: { id },
            data: { aktif },
        })

        await logSistem("INFO", "RECURRING", `Transaksi berulang ${aktif ? 'diaktifkan' : 'dinonaktifkan'}: ${recurring.nama}`)
        revalidatePath("/recurring")

        return { success: true, data: recurring }
    } catch (error) {
        return { success: false, error: "Gagal mengubah status" }
    }
}

export async function deleteRecurringTransaction(id: string) {
    try {
        const recurring = await prisma.recurringTransaction.delete({
            where: { id },
        })

        await logSistem("INFO", "RECURRING", `Transaksi berulang dihapus: ${recurring.nama}`)
        revalidatePath("/recurring")

        return { success: true }
    } catch (error) {
        return { success: false, error: "Gagal menghapus" }
    }
}

// Jalankan transaksi berulang yang pending
export async function executeRecurringTransactions() {
    try {
        const now = new Date()
        const today = now.getDate()
        const dayOfWeek = now.getDay() // 0 = Minggu

        // Ambil semua recurring yang aktif
        const activeRecurring = await prisma.recurringTransaction.findMany({
            where: {
                aktif: true,
                OR: [
                    { tanggalSelesai: null },
                    { tanggalSelesai: { gte: now } }
                ]
            }
        })

        let executed = 0

        for (const recurring of activeRecurring) {
            let shouldExecute = false

            // Cek apakah sudah dieksekusi hari ini
            if (recurring.terakhirDieksekusi) {
                const lastExec = new Date(recurring.terakhirDieksekusi)
                if (lastExec.toDateString() === now.toDateString()) {
                    continue // Sudah dieksekusi hari ini
                }
            }

            switch (recurring.frekuensi) {
                case "HARIAN":
                    shouldExecute = true
                    break
                case "MINGGUAN":
                    shouldExecute = recurring.hariDalamMinggu === dayOfWeek
                    break
                case "BULANAN":
                    shouldExecute = recurring.hariDalamBulan === today
                    break
                case "TAHUNAN":
                    // Untuk tahunan, cek bulan dan tanggal
                    const startDate = new Date(recurring.tanggalMulai)
                    shouldExecute =
                        startDate.getMonth() === now.getMonth() &&
                        startDate.getDate() === today
                    break
            }

            if (shouldExecute) {
                // Generate idempotency key: recurring_{id}_{YYYY-MM-DD}
                const dateKey = now.toISOString().split('T')[0]
                const idempotencyKey = `recurring_${recurring.id}_${dateKey}`

                // Fix Idempotency Check: Check BEFORE starting transaction
                const existing = await prisma.transaksi.findUnique({
                    where: { idempotencyKey }
                })
                
                if (existing) {
                    await logSistem("WARN", "RECURRING", `Skip duplikasi eksekusi: ${recurring.nama} (${idempotencyKey})`)
                    continue
                }

                // Buat transaksi
                const kategoriTipe = recurring.tipeTransaksi === "KELUAR" ? "EXPENSE" : "INCOME"

                // Cari atau buat akun kategori
                const namaAkun = `[${kategoriTipe}] ${recurring.kategori}`
                let kategoriAkun = await prisma.akun.findFirst({
                    where: { nama: namaAkun }
                })

                if (!kategoriAkun) {
                    kategoriAkun = await prisma.akun.create({
                        data: {
                            nama: namaAkun,
                            tipe: kategoriTipe,
                            saldoAwal: BigInt(0),
                            saldoSekarang: BigInt(0),
                        }
                    })
                }

                const debitAkunId = recurring.tipeTransaksi === "KELUAR" ? kategoriAkun.id : recurring.akunId
                const kreditAkunId = recurring.tipeTransaksi === "KELUAR" ? recurring.akunId : kategoriAkun.id

                try {
                    const nominalInt = BigInt(Money.fromFloat(recurring.nominal))

                    await prisma.$transaction(async (tx: any) => {
                        // Buat transaksi
                        await tx.transaksi.create({
                            data: {
                                deskripsi: `[Auto] ${recurring.nama}`,
                                nominal: nominalInt, // BigInt from Float
                                kategori: recurring.kategori,
                                debitAkunId,
                                kreditAkunId,
                                tanggal: now,
                                catatan: "Dibuat otomatis dari transaksi berulang",
                                idempotencyKey,
                            }
                        })

                        // Update saldo
                        await tx.akun.update({
                            where: { id: debitAkunId },
                            data: { saldoSekarang: { increment: nominalInt } }
                        })
                        await tx.akun.update({
                            where: { id: kreditAkunId },
                            data: { saldoSekarang: { decrement: nominalInt } }
                        })

                        // Update terakhirDieksekusi
                        await tx.recurringTransaction.update({
                            where: { id: recurring.id },
                            data: { terakhirDieksekusi: now }
                        })
                    })

                    executed++
                } catch (txError: any) {
                     // Catch race condition if any
                    if (txError.code === 'P2002') {
                        await logSistem("WARN", "RECURRING", `Skip duplikasi eksekusi (Race): ${recurring.nama} (${idempotencyKey})`)
                        continue
                    }
                    throw txError // Re-throw if other error
                }
            }
        }

        if (executed > 0) {
            await logSistem("INFO", "RECURRING", `Eksekusi transaksi berulang: ${executed} transaksi`)
            
            // Trigger background snapshot (non-blocking)
            void saveNetWorthSnapshot()
            
            revalidatePath("/")
            revalidatePath("/transaksi")
            revalidatePath("/akun")
        }

        return { success: true, executed }
    } catch (error) {
        await logSistem("ERROR", "RECURRING", "Gagal eksekusi transaksi berulang", (error as Error).stack)
        return { success: false, error: "Gagal eksekusi transaksi berulang" }
    }
}

```

## File: src\app\actions\seed.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"

export async function seedInitialData() {
    try {
        const accountCount = await prisma.akun.count()
        if (accountCount > 0) return { success: true, message: "Data sudah ada" }

        await prisma.$transaction([
            // Akun Aset / Sumber Dana
            prisma.akun.create({ data: { nama: "BCA Tahapan", tipe: "BANK", saldoAwal: 0, saldoSekarang: 0, warna: "#005696" } }),
            prisma.akun.create({ data: { nama: "Gopay", tipe: "E_WALLET", saldoAwal: 0, saldoSekarang: 0, warna: "#00AA13" } }),
            prisma.akun.create({ data: { nama: "Tunai", tipe: "CASH", saldoAwal: 0, saldoSekarang: 0, warna: "#4CAF50" } }),

            // Akun PENGELUARAN (Kategori)
            prisma.akun.create({ data: { nama: "Beban Makan & Minum", tipe: "PENGELUARAN", saldoAwal: 0, saldoSekarang: 0 } }),
            prisma.akun.create({ data: { nama: "Beban Transportasi", tipe: "PENGELUARAN", saldoAwal: 0, saldoSekarang: 0 } }),
            prisma.akun.create({ data: { nama: "Beban Listrik & Air", tipe: "PENGELUARAN", saldoAwal: 0, saldoSekarang: 0 } }),
            prisma.akun.create({ data: { nama: "Beban Cicilan", tipe: "PENGELUARAN", saldoAwal: 0, saldoSekarang: 0 } }),

            // Akun PENDAPATAN
            prisma.akun.create({ data: { nama: "Pendapatan Gaji", tipe: "PENDAPATAN", saldoAwal: 0, saldoSekarang: 0 } }),
            prisma.akun.create({ data: { nama: "Pendapatan Bonus", tipe: "PENDAPATAN", saldoAwal: 0, saldoSekarang: 0 } }),
        ])

        await logSistem("INFO", "SYSTEM", "Data inisial (PSAK) berhasil di-seed")
        return { success: true, message: "Data berhasil di-seed" }
    } catch (error) {
        await logSistem("ERROR", "SYSTEM", "Gagal melakukan seeding data", (error as Error).stack)
        return { success: false, error: "Gagal seeding" }
    }
}

// Seed Installment Templates (v0.5.0)
export async function seedInstallmentTemplates() {
    try {
        const templateCount = await prisma.installmentTemplate.count()
        if (templateCount > 0) return { success: true, message: "Template cicilan sudah ada" }

        const cimbTemplates = [
            {
                nama: "CIMB Niaga 0% 3 Bulan (App)",
                bankName: "CIMB Niaga",
                cardType: "KONVENSIONAL",
                tenorOptions: JSON.stringify([3]),
                adminFeeType: "FLAT",
                adminFeeAmount: 25000,
                interestRate: 0,
                notes: "Biaya admin Rp 25.000 untuk konversi via aplikasi OCTO"
            },
            {
                nama: "CIMB Niaga 0% 3 Bulan (Call Center)",
                bankName: "CIMB Niaga",
                cardType: "KONVENSIONAL",
                tenorOptions: JSON.stringify([3]),
                adminFeeType: "FLAT",
                adminFeeAmount: 50000,
                interestRate: 0,
                notes: "Biaya admin Rp 50.000 untuk konversi via call center 14041"
            },
            {
                nama: "CIMB Niaga Syariah 0% 3 Bulan (App)",
                bankName: "CIMB Niaga",
                cardType: "SYARIAH",
                tenorOptions: JSON.stringify([3]),
                adminFeeType: "FLAT",
                adminFeeAmount: 25000,
                interestRate: 0,
                notes: "Biaya admin Rp 25.000 untuk konversi via aplikasi OCTO"
            }
        ]

        for (const template of cimbTemplates) {
            await prisma.installmentTemplate.create({ data: template })
        }

        await logSistem("INFO", "SYSTEM", `${cimbTemplates.length} template cicilan CIMB Niaga berhasil di-seed`)
        return { success: true, message: `${cimbTemplates.length} template berhasil dibuat` }
    } catch (error) {
        await logSistem("ERROR", "SYSTEM", "Gagal seeding template cicilan", (error as Error).stack)
        return { success: false, error: "Gagal seeding template" }
    }
}

// Migrate existing credit cards to have default values (for demo)
export async function migrateCreditCardDefaults() {
    try {
        const creditCards = await prisma.akun.findMany({
            where: {
                tipe: "CREDIT_CARD",
                isSyariah: null // Only update ones without values
            }
        })

        if (creditCards.length === 0) {
            return { success: true, message: "Tidak ada kartu kredit yang perlu dimigrasi" }
        }

        let updated = 0
        for (const card of creditCards) {
            await prisma.akun.update({
                where: { id: card.id },
                data: {
                    isSyariah: false, // Default: Konvensional
                    billingDate: 25,  // Default: tanggal 25
                    dueDate: 15,      // Default: tanggal 15
                    minPaymentFixed: 50000,
                    minPaymentPercent: 5
                }
            })
            updated++
        }

        await logSistem("INFO", "SYSTEM", `${updated} kartu kredit dimigrasi dengan nilai default`)
        return { success: true, message: `${updated} kartu kredit diperbarui dengan nilai default` }
    } catch (error) {
        await logSistem("ERROR", "SYSTEM", "Gagal migrasi kartu kredit", (error as Error).stack)
        return { success: false, error: "Gagal migrasi" }
    }
}


```

## File: src\app\actions\template.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { Money } from "@/lib/money"

// ============================================
// ACCOUNT TEMPLATE (PERBANKAN)
// ============================================

export interface AccountTemplateData {
    id?: string
    nama: string
    tipeAkun: string
    biayaAdmin?: number | null
    bungaTier?: string | null
    polaTagihan: string
    tanggalTagihan?: number | null
    deskripsi?: string
    isActive?: boolean
}

export async function createAccountTemplate(data: AccountTemplateData) {
    try {
        const template = await prisma.accountTemplate.create({
            data: {
                nama: data.nama,
                tipeAkun: data.tipeAkun,
                biayaAdmin: data.biayaAdmin,
                bungaTier: data.bungaTier,
                polaTagihan: data.polaTagihan,
                tanggalTagihan: data.tanggalTagihan,
                deskripsi: data.deskripsi,
                isActive: data.isActive ?? true,
            }
        })

        await logSistem("INFO", "TEMPLATE", `Account Template dibuat: ${data.nama}`)
        revalidatePath("/template-akun")
        return { success: true, data: template }
    } catch (error) {
        await logSistem("ERROR", "TEMPLATE", "Gagal membuat account template", (error as Error).stack)
        return { success: false, error: "Gagal membuat account template" }
    }
}

export async function updateAccountTemplate(id: string, data: Partial<AccountTemplateData>) {
    try {
        const template = await prisma.accountTemplate.update({
            where: { id },
            data: {
                nama: data.nama,
                tipeAkun: data.tipeAkun,
                biayaAdmin: data.biayaAdmin,
                bungaTier: data.bungaTier,
                polaTagihan: data.polaTagihan,
                tanggalTagihan: data.tanggalTagihan,
                deskripsi: data.deskripsi,
                isActive: data.isActive,
            }
        })

        await logSistem("INFO", "TEMPLATE", `Account Template diupdate: ${template.nama}`)
        revalidatePath("/template-akun")
        revalidatePath("/akun")
        return { success: true, data: template }
    } catch (error) {
        await logSistem("ERROR", "TEMPLATE", "Gagal update account template", (error as Error).stack)
        return { success: false, error: "Gagal update account template" }
    }
}

export async function getAccountTemplates() {
    try {
        const templates = await prisma.accountTemplate.findMany({
            orderBy: { nama: "asc" }
        })
        return { success: true, data: templates }
    } catch (error) {
        return { success: false, data: [] }
    }
}

export async function getActiveAccountTemplates() {
    try {
        const templates = await prisma.accountTemplate.findMany({
            where: { isActive: true },
            orderBy: { nama: "asc" }
        })
        return { success: true, data: templates }
    } catch (error) {
        return { success: false, data: [] }
    }
}

export async function deleteAccountTemplate(id: string) {
    try {
        // Soft delete: set isActive to false if there are accounts using it
        const accountsCount = await prisma.akun.count({ where: { templateId: id } })
        
        if (accountsCount > 0) {
            await prisma.accountTemplate.update({
                where: { id },
                data: { isActive: false }
            })
            await logSistem("INFO", "TEMPLATE", `Account Template dinonaktifkan (digunakan oleh ${accountsCount} akun)`)
        } else {
            await prisma.accountTemplate.delete({ where: { id } })
            await logSistem("INFO", "TEMPLATE", "Account Template dihapus permanen")
        }

        revalidatePath("/template-akun")
        return { success: true }
    } catch (error) {
        return { success: false, error: "Gagal menghapus account template" }
    }
}

export async function toggleAccountTemplateStatus(id: string) {
    try {
        const template = await prisma.accountTemplate.findUnique({ where: { id } })
        if (!template) return { success: false, error: "Template tidak ditemukan" }

        const updated = await prisma.accountTemplate.update({
            where: { id },
            data: { isActive: !template.isActive }
        })

        await logSistem("INFO", "TEMPLATE", `Status template ${updated.nama} diubah menjadi ${updated.isActive ? 'Aktif' : 'Non-Aktif'}`)
        revalidatePath("/template-akun")
        return { success: true, data: updated }
    } catch (error) {
        return { success: false, error: "Gagal mengubah status template" }
    }
}

// ============================================
// TEMPLATE TRANSAKSI
// ============================================

export interface TemplateData {
    nama: string
    deskripsi: string
    nominal: number
    kategori: string
    tipeTransaksi: "KELUAR" | "MASUK"
    akunId: string
    icon?: string
    warna?: string
}

// Buat template baru
export async function createTemplate(data: TemplateData) {
    try {
        const template = await prisma.templateTransaksi.create({
            data: {
                nama: data.nama,
                deskripsi: data.deskripsi,
                nominal: data.nominal,
                kategori: data.kategori,
                tipeTransaksi: data.tipeTransaksi,
                akunId: data.akunId,
                icon: data.icon,
                warna: data.warna,
            }
        })

        await logSistem("INFO", "TEMPLATE", `Template dibuat: ${data.nama}`)
        revalidatePath("/template")
        revalidatePath("/transaksi")

        return { success: true, data: template }
    } catch (error) {
        await logSistem("ERROR", "TEMPLATE", "Gagal membuat template", (error as Error).stack)
        return { success: false, error: "Gagal membuat template" }
    }
}

// Ambil semua template
export async function getTemplates() {
    try {
        const templates = await prisma.templateTransaksi.findMany({
            orderBy: [
                { usageCount: "desc" },
                { nama: "asc" }
            ]
        })
        return { success: true, data: templates }
    } catch (error) {
        return { success: false, data: [] }
    }
}

// Gunakan template untuk membuat transaksi
export async function useTemplate(templateId: string, tanggal?: Date) {
    try {
        const template = await prisma.templateTransaksi.findUnique({
            where: { id: templateId }
        })

        if (!template) {
            return { success: false, error: "Template tidak ditemukan" }
        }

        // Cari akun expense/income sesuai kategori
        const kategoriAkun = await prisma.akun.findFirst({
            where: {
                nama: template.tipeTransaksi === "KELUAR"
                    ? `[EXPENSE] ${template.kategori}`
                    : `[INCOME] ${template.kategori}`
            }
        })

        if (!kategoriAkun) {
            return { success: false, error: "Kategori tidak ditemukan" }
        }

        const nominalInt = BigInt(Money.fromFloat(template.nominal))

        // Buat transaksi berdasarkan template
        const transaksi = await prisma.transaksi.create({
            data: {
                tanggal: tanggal || new Date(),
                deskripsi: template.deskripsi,
                nominal: nominalInt, // BigInt
                kategori: template.kategori,
                debitAkunId: template.tipeTransaksi === "KELUAR" ? kategoriAkun.id : template.akunId,
                kreditAkunId: template.tipeTransaksi === "KELUAR" ? template.akunId : kategoriAkun.id,
                idempotencyKey: `template-${templateId}-${Date.now()}`,
            }
        })

        // Update saldo akun
        if (template.tipeTransaksi === "KELUAR") {
            await prisma.akun.update({
                where: { id: template.akunId },
                data: { saldoSekarang: { decrement: nominalInt } }
            })
        } else {
            await prisma.akun.update({
                where: { id: template.akunId },
                data: { saldoSekarang: { increment: nominalInt } }
            })
        }

        // Increment usage count
        await prisma.templateTransaksi.update({
            where: { id: templateId },
            data: { usageCount: { increment: 1 } }
        })

        await logSistem("INFO", "TEMPLATE", `Template digunakan: ${template.nama}`)
        revalidatePath("/")
        revalidatePath("/transaksi")

        const mappedResult = {
            ...transaksi,
            nominal: Money.toFloat(Number(transaksi.nominal))
        }

        return { success: true, data: mappedResult }
    } catch (error) {
        await logSistem("ERROR", "TEMPLATE", "Gagal menggunakan template", (error as Error).stack)
        return { success: false, error: "Gagal menggunakan template" }
    }
}

// Hapus template
export async function deleteTemplate(id: string) {
    try {
        await prisma.templateTransaksi.delete({
            where: { id }
        })

        await logSistem("INFO", "TEMPLATE", "Template dihapus")
        revalidatePath("/template")

        return { success: true }
    } catch (error) {
        return { success: false, error: "Gagal menghapus template" }
    }
}

// Simpan transaksi sebagai template
export async function saveAsTemplate(transaksiId: string, nama: string) {
    try {
        const transaksi = await prisma.transaksi.findUnique({
            where: { id: transaksiId },
            include: {
                debitAkun: true,
                kreditAkun: true
            }
        })

        if (!transaksi) {
            return { success: false, error: "Transaksi tidak ditemukan" }
        }

        // Tentukan tipe dan akun
        const isKeluar = transaksi.debitAkun.tipe === "EXPENSE"
        const akunId = isKeluar ? transa
... (truncated)
```

## File: src\app\actions\transaksi.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"
import { saveNetWorthSnapshot } from "@/app/actions/networth"
import { Money } from "@/lib/money"
import { ErrorMessages } from "@/lib/constants/error-messages"
import { TransaksiSchema } from "@/lib/validations/transaksi"
import { ServerActionResult } from "@/types"

// Untuk pagination - 25 item per halaman untuk tampilan lebih lengkap
const PAGE_SIZE = 25

// Tipe akun user
const USER_ACCOUNT_TYPES = ["BANK", "E_WALLET", "CASH", "CREDIT_CARD"]

interface TransaksiFilter {
    page?: number
    search?: string
    kategori?: string
    tipe?: string // "expense" | "income"
    dateFrom?: string
    dateTo?: string
    minNominal?: number
    maxNominal?: number
    sort?: string // "tanggal" | "nominal" | "kategori"
    sortDir?: string // "asc" | "desc"
    akunId?: string // Tambahkan filter akunId
}

export async function getTransaksi(filters: TransaksiFilter = {}) {
    const {
        page = 1,
        search,
        kategori,
        tipe,
        dateFrom,
        dateTo,
        minNominal,
        maxNominal,
        sort = "tanggal",
        sortDir = "desc",
        akunId
    } = filters

    try {
        const skip = (page - 1) * PAGE_SIZE

        // Build where clause dynamically
        const where: any = {}

        if (akunId) {
            where.OR = [
                { debitAkunId: akunId },
                { kreditAkunId: akunId }
            ]
        }

        if (search) {
            where.OR = [
                { deskripsi: { contains: search } },
                { kategori: { contains: search } },
                { catatan: { contains: search } },
                // Support search by akun name
                { debitAkun: { nama: { contains: search } } },
                { kreditAkun: { nama: { contains: search } } },
            ]
        }

        if (kategori) {
            where.kategori = kategori
        }

        if (tipe === "expense") {
            // Pengeluaran: debitAkun adalah EXPENSE atau kreditAkun adalah akun user
            where.debitAkun = { tipe: "EXPENSE" }
        } else if (tipe === "income") {
            // Pemasukan: kreditAkun adalah INCOME atau debitAkun adalah akun user
            where.kreditAkun = { tipe: "INCOME" }
        }

        // Date range filter
        if (dateFrom || dateTo) {
            where.tanggal = {}
            if (dateFrom) {
                where.tanggal.gte = new Date(dateFrom)
            }
            if (dateTo) {
                // Set to end of day
                const endDate = new Date(dateTo)
                endDate.setHours(23, 59, 59, 999)
                where.tanggal.lte = endDate
            }
        }

        // Nominal range filter
        if (minNominal !== undefined || maxNominal !== undefined) {
            where.nominal = {}
            if (minNominal !== undefined && minNominal > 0) {
                where.nominal.gte = BigInt(Money.fromFloat(minNominal))
            }
            if (maxNominal !== undefined && maxNominal > 0) {
                where.nominal.lte = BigInt(Money.fromFloat(maxNominal))
            }
        }

        // Build orderBy
        const orderBy: any[] = []
        const validSort = ["tanggal", "nominal", "kategori"].includes(sort) ? sort : "tanggal"
        const validDir = sortDir === "asc" ? "asc" : "desc"
        
        orderBy.push({ [validSort]: validDir })
        
        // Add stable secondary sort for deterministic results
        if (validSort !== "id") {
            orderBy.push({ id: "desc" })
        }

        const [transaksi, total] = await Promise.all([
            prisma.transaksi.findMany({
                where,
                include: {
                    debitAkun: true,
                    kreditAkun: true,
                },
                orderBy,
                skip,
                take: PAGE_SIZE,
            }),
            prisma.transaksi.count({ where }),
        ])

        // Kalkulasi Running Balance jika memfilter per akun
        let dataWithBalance = transaksi.map(tx => ({
             ...tx,
             // CAST BigInt to Number (Float) for UI
             nominal: Money.toFloat(Number(tx.nominal)),
             _nominalBigInt: tx.nominal
        }))

        if (akunId && sort === "tanggal") {
            // Ambil saldo saat ini dari akun tersebut (BigInt)
            const akun = await prisma.akun.findUnique({
                where: { id: akunId },
                select: { saldoSekarang: true }
            })

            if (akun) {
                // Convert BigInt -> Number (Float) for calculation logic
                let currentRunningBalance = Money.toFloat(Number(akun.saldoSekarang))

                // Perbaikan: Jika bukan halaman pertama, sesuaikan saldo awal running balance
                if (page > 1) {
                    const skippedTx = await prisma.transaksi.findMany({
                        where,
                        orderBy,
                        take: skip,
                        select: {
                            nominal: true, // BigInt
                            debitAkunId: true,
                        }
                    })

                    for (const tx of skippedTx) {
                        const nominal = Money.toFloat(Number(tx.nominal))
                        const isDebit = tx.debitAkunId === akunId
                        if (isDebit) {
                            currentRunningBalance -= nominal
                        } else {
                            currentRunningBalance += nominal
                        }
                    }
                }

                // Hitung mundur
                dataWithBalance = dataWithBalance.map((tx) => {
                    const txWithBalance = {
                        ...tx,
                        saldoSetelah: currentRunningBalance
                    }
                    
                    const isDebit = tx.debitAkunId === akunId
                    if (isDebit) {
                        currentRunningBalance -= tx.nominal // tx.nominal is Float here (mapped above)
                    } else {
                        currentRunningBalance += tx.nominal
                    }

                    return txWithBalance
                })
            }
        }

        return {
            data: dataWithBalance,
            pagination: {
                page,
                pageSize: PAGE_SIZE,
                total,
                totalPages: Math.ceil(total / PAGE_SIZE),
            },
        }
    } catch (error) {
        await logSistem("ERROR", "TRANSAKSI", "Gagal mengambil data transaksi", (error as Error).stack)
        throw new Error("Gagal mengambil data transaksi")
    }
}


// Helper untuk mendapatkan atau membuat akun kategori internal
async function getOrCreateKategoriAkun(tx: any, kategori: string, tipe: "EXPENSE" | "INCOME") {
    const namaAkun = `[${tipe}] ${kategori}`

    let akun = await tx.akun.findFirst({
        where: { nama: namaAkun, tipe }
    })

    if (!akun) {
        akun = await tx.akun.create({
            data: {
                nama: namaAkun,
                tipe,
                saldoAwal: BigInt(0),
                saldoSekarang: BigInt(0),
            }
        })
    }

    return akun
}

// Interface untuk createTransaksiSimple
interface SimpleTransaksiData {
    nominal: number
    kategori: string
    akunId: string // Akun uang user (Bank, E-Wallet, dll)
    tipeTransaksi: "KELUAR" | "MASUK"
    deskripsi?: string
    tanggal?: Date // Custom date, default hari ini
    idempotencyKey?: string
}

export async function createTransaksiSimple(data: SimpleTransaksiData): Promise<ServerActionResult<any>> {
    // 1. Validation with Zod
    const validation = TransaksiSchema.safeParse({
        ...data,
        tanggal: data.tanggal || new Date()
    })

    if (!validation.success) {
        return { 
            success: false, 
            error: "Data transaksi tidak valid", 
            errors: validation.error.flatten().fieldErrors 
        }
    }

    try {
        // 2. Cek idempotency key jika ada
        if (data.idempotencyKey) {
            const existing = await prisma.transaksi.findUnique({
                where: { idempotencyKey: data.idempotencyKey }
            })
            if (existing) {
                // Convert BigInt to Float for return
                const mapped = {
                    ...existing,
                    nominal: Money.toFloat(Number(existing.nominal))
                }
                return { success: true, data: mapped, duplicated: true }
            }
        }

        // 3. Jalankan transaksi database (Atomic)
        const result = await prisma.$transaction(async (tx: any) => {
            // Ambil atau buat akun kategori internal
            const kategoriTipe = data.tipeTransaksi === "KELUAR" ? "EXPENSE" : "INCOME"
            const kategoriAkun = await getOrCreateKategoriAkun(tx, data.kategori, kategoriTipe)

            const debitAkunId = data.tipeTransaksi === "KELUAR" ? kategoriAkun.id : data.akunId
            const kreditAkunId = data.tipeTransaksi === "KELUAR" ? data.akunId : kategoriAkun.id

            const nominalInt = BigInt(Money.fromFloat(data.nominal))

            // Buat record transaksi
            const transaksi = await tx.transaksi.create({
                data: {
                    deskripsi: data.deskripsi || data.kategori,
                    nominal: nominalInt, // BigInt
                    kategori: data.kategori,
                    debitAkunId,
                    kreditAkunId,
                    tanggal: data.tanggal || new Date(),
                    idempotencyKey: data.idempotencyKey,
                },
            })

            // Update saldo akun debit (bertambah)
            await tx.akun.update({
                where: { id: debitAkunId },
             
... (truncated)
```

## File: src\app\actions\transfer.ts
```typescript
"use server"

import prisma from "@/lib/prisma"
import { logSistem } from "@/lib/logger"
import { revalidatePath } from "next/cache"

interface TransferData {
    dariAkunId: string
    keAkunId: string
    nominal: number
    catatan?: string
    tanggal?: Date
    idempotencyKey?: string
}

export async function createTransfer(data: TransferData) {
    try {
        // Validasi
        if (data.dariAkunId === data.keAkunId) {
            return { success: false, error: "Akun asal dan tujuan tidak boleh sama" }
        }

        if (data.nominal <= 0) {
            return { success: false, error: "Nominal harus lebih dari 0" }
        }

        // Cek idempotency key jika ada
        if (data.idempotencyKey) {
            const existing = await prisma.transaksi.findUnique({
                where: { idempotencyKey: data.idempotencyKey }
            })
            if (existing) return { success: true, data: existing, duplicated: true }
        }

        // Jalankan transaksi database (Atomic)
        const result = await prisma.$transaction(async (tx: any) => {
            // Ambil data akun
            const dariAkun = await tx.akun.findUnique({
                where: { id: data.dariAkunId }
            })
            const keAkun = await tx.akun.findUnique({
                where: { id: data.keAkunId }
            })

            if (!dariAkun || !keAkun) {
                throw new Error("Akun tidak ditemukan")
            }

            // Buat deskripsi otomatis
            const deskripsi = data.catatan || `Transfer ke ${keAkun.nama}`

            // Buat record transaksi
            // Transfer: Debit = akun tujuan (bertambah), Kredit = akun asal (berkurang)
            const transaksi = await tx.transaksi.create({
                data: {
                    deskripsi,
                    nominal: data.nominal,
                    kategori: "Transfer",
                    debitAkunId: data.keAkunId,    // Tujuan (bertambah)
                    kreditAkunId: data.dariAkunId, // Asal (berkurang)
                    tanggal: data.tanggal || new Date(),
                    catatan: `Transfer dari ${dariAkun.nama} ke ${keAkun.nama}`,
                    idempotencyKey: data.idempotencyKey,
                },
            })

            // Update saldo akun tujuan (bertambah)
            await tx.akun.update({
                where: { id: data.keAkunId },
                data: { saldoSekarang: { increment: data.nominal } }
            })

            // Update saldo akun asal (berkurang)
            await tx.akun.update({
                where: { id: data.dariAkunId },
                data: { saldoSekarang: { decrement: data.nominal } }
            })

            return { transaksi, dariAkun, keAkun }
        })

        await logSistem(
            "INFO",
            "TRANSFER",
            `Transfer berhasil: ${result.dariAkun.nama}  ${result.keAkun.nama} (${data.nominal})`
        )

        revalidatePath("/")
        revalidatePath("/akun")
        revalidatePath("/transaksi")

        return { success: true, data: result.transaksi }
    } catch (error) {
        await logSistem("ERROR", "TRANSFER", "Gagal melakukan transfer", (error as Error).stack)
        return { success: false, error: (error as Error).message || "Gagal melakukan transfer" }
    }
}

```
# Libraries (src/lib)


## File: src\lib\constants\error-messages.ts
```typescript
import { formatRupiah } from "@/lib/format"

export const ErrorMessages = {
    INSUFFICIENT_BALANCE: (available: number, needed: number) => 
        `Saldo tidak cukup. Tersedia: ${formatRupiah(available)}, butuh: ${formatRupiah(needed)}`,
    
    ACCOUNT_NOT_FOUND: (id: string) => 
        `Akun tidak ditemukan (ID: ${id.slice(0, 8)}...)`,
    
    DUPLICATE_TRANSACTION: (date: Date) => 
        `Transaksi dengan tanggal ${date.toLocaleDateString('id-ID')} sudah ada`,
    
    INVALID_AMOUNT: (amount: number) => 
        `Nominal tidak valid: ${formatRupiah(amount)}. Minimal Rp 100`,
    
    CREDIT_CARD_LIMIT_EXCEEDED: (limit: number, current: number, attempt: number) =>
        `Limit kartu kredit terlampaui!\n` +
        `Limit: ${formatRupiah(limit)}\n` +
        `Terpakai: ${formatRupiah(Math.abs(current))}\n` +
        `Transaksi: ${formatRupiah(attempt)}\n` +
        `Tersisa: ${formatRupiah(limit + current - attempt)}`,
    
    GENERAL_ERROR: "Terjadi kesalahan sistem. Silakan coba lagi.",
    UNAUTHORIZED: "Anda tidak memiliki akses untuk melakukan tindakan ini.",
}

```

## File: src\lib\currency.ts
```typescript
// Mata uang yang didukung
export const SUPPORTED_CURRENCIES = [
    { kode: "IDR", nama: "Rupiah Indonesia", simbol: "Rp", flag: "" },
    { kode: "USD", nama: "US Dollar", simbol: "$", flag: "" },
    { kode: "EUR", nama: "Euro", simbol: "", flag: "" },
    { kode: "SGD", nama: "Singapore Dollar", simbol: "S$", flag: "" },
    { kode: "MYR", nama: "Malaysian Ringgit", simbol: "RM", flag: "" },
    { kode: "JPY", nama: "Japanese Yen", simbol: "", flag: "" },
    { kode: "GBP", nama: "British Pound", simbol: "", flag: "" },
    { kode: "AUD", nama: "Australian Dollar", simbol: "A$", flag: "" },
    { kode: "CNY", nama: "Chinese Yuan", simbol: "", flag: "" },
    { kode: "KRW", nama: "Korean Won", simbol: "", flag: "" },
]

// Default rates (approximate, as fallback)
export const DEFAULT_RATES: Record<string, number> = {
    USD: 15800,
    EUR: 17200,
    SGD: 11800,
    MYR: 3500,
    JPY: 105,
    GBP: 20000,
    AUD: 10200,
    CNY: 2200,
    KRW: 12,
}

// Get currency info by code
export function getCurrencyInfo(kode: string) {
    return SUPPORTED_CURRENCIES.find(c => c.kode === kode)
}

// Simbol mata uang
export const CURRENCY_SYMBOLS: Record<string, string> = {
    IDR: "Rp",
    USD: "$",
    EUR: "",
    SGD: "S$",
    MYR: "RM",
    JPY: "",
    GBP: "",
    AUD: "A$",
    CNY: "",
    KRW: "",
}

```

## File: src\lib\decimal-utils.ts
```typescript
// Decimal formatting utilities for credit card display
// CIMB Niaga uses 2 decimal places (1.203.930,88), others use whole numbers

/**
 * Format rupiah with optional decimal places
 * @param amount - Amount to format
 * @param useDecimals - If true, use 2 decimal places (CIMB style)
 */
export function formatRupiahDecimal(amount: number, useDecimals: boolean = false): string {
    const isNegative = amount < 0
    const absAmount = Math.abs(amount)

    if (useDecimals) {
        // CIMB style: 1.203.930,88
        const formatted = absAmount.toLocaleString('id-ID', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        })
        return `${isNegative ? '-' : ''}Rp ${formatted}`
    }

    // Standard style: 1.203.931 (rounded)
    return `${isNegative ? '-' : ''}Rp ${Math.round(absAmount).toLocaleString('id-ID')}`
}

/**
 * Check if account name indicates CIMB bank (uses 2 decimal format)
 */
export function usesCimbFormat(akunNama: string): boolean {
    return akunNama.toLowerCase().includes("cimb")
}

/**
 * Calculate late fee based on card type and days past due
 * @param fullPayment - Total payment amount
 * @param isSyariah - Card type (true = Syariah)
 * @param daysPastDue - Days past due date (0 if not yet due)
 */
export function calculateLateFee(
    fullPayment: number,
    isSyariah: boolean,
    daysPastDue: number
): number {
    if (daysPastDue <= 0) return 0

    if (isSyariah) {
        // Ta'widh: Rp 75.000 (30 hari) atau Rp 100.000 (>30 hari)
        return daysPastDue <= 30 ? 75000 : 100000
    }

    // Konvensional: 1% dari total tagihan, max Rp 100.000
    const fee = fullPayment * 0.01
    return Math.min(fee, 100000)
}

/**
 * Calculate minimum payment based on full payment and account settings
 */
export function calculateMinimumPayment(
    fullPayment: number,
    minPaymentPercent: number = 5,
    minPaymentFixed: number = 50000
): number {
    const percentBased = fullPayment * (minPaymentPercent / 100)
    return Math.max(percentBased, minPaymentFixed)
}

/**
 * Get billing period dates for a credit card
 * Billing period: day 1 to billingDate of current month
 */
export function getBillingPeriod(billingDate: number): { start: Date; end: Date } {
    const now = new Date()
    const currentMonth = now.getMonth()
    const currentYear = now.getFullYear()

    // Start of billing period (1st of current month)
    const start = new Date(currentYear, currentMonth, 1)
    start.setHours(0, 0, 0, 0)

    // End of billing period (billingDate of current month)
    const end = new Date(currentYear, currentMonth, billingDate)
    end.setHours(23, 59, 59, 999)

    return { start, end }
}

/**
 * Get due date and calculate days until/past due
 */
export function getDueDateInfo(dueDate: number, billingDate: number): {
    dueDateTime: Date
    daysUntilDue: number
    isPastDue: boolean
} {
    const now = new Date()
    const currentMonth = now.getMonth()
    const currentYear = now.getFullYear()

    // Due date can be in same month or next month based on configuration
    // If dueDate < billingDate, due date is in next month
    let dueDateObj: Date
    if (dueDate >= billingDate) {
        dueDateObj = new Date(currentYear, currentMonth, dueDate)
    } else {
        dueDateObj = new Date(currentYear, currentMonth + 1, dueDate)
    }

    dueDateObj.setHours(23, 59, 59, 999)

    const timeDiff = dueDateObj.getTime() - now.getTime()
    const daysUntilDue = Math.ceil(timeDiff / (1000 * 60 * 60 * 24))

    return {
        dueDateTime: dueDateObj,
        daysUntilDue,
        isPastDue: daysUntilDue < 0
    }
}

```

## File: src\lib\format.ts
```typescript
import { Money } from "./money"

export function formatRupiah(amount: number) {
    // Gunakan Money utility untuk format yang konsisten (2 desimal)
    // Money.format menerima Integer (Sen), jadi konversi dulu
    return Money.format(Money.fromFloat(amount))
}

// Simbol mata uang
const CURRENCY_SYMBOLS: Record<string, string> = {
    IDR: "Rp",
    USD: "$",
    EUR: "",
    SGD: "S$",
    MYR: "RM",
    JPY: "",
    GBP: "",
    AUD: "A$",
    CNY: "",
    KRW: "",
}

// Format currency berdasarkan kode mata uang
export function formatCurrency(amount: number, currencyCode: string = "IDR"): string {
    const isNegative = amount < 0
    const absAmount = Math.abs(amount)
    const symbol = CURRENCY_SYMBOLS[currencyCode] || currencyCode

    if (currencyCode === "IDR") {
        return `${isNegative ? '-' : ''}${symbol} ${absAmount.toLocaleString('id-ID')}`
    }

    // Format untuk mata uang asing dengan 2 desimal
    const formatted = absAmount.toLocaleString('en-US', {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    })

    return `${isNegative ? '-' : ''}${symbol} ${formatted}`
}

```

## File: src\lib\logger.ts
```typescript
import prisma from "./prisma"

type LogLevel = "INFO" | "WARN" | "ERROR"

export async function logSistem(level: LogLevel, modul: string, pesan: string, stackTrace?: string) {
    const timestamp = new Date().toISOString()
    console.log(`[KEU-LOG] [${timestamp}] [${level}] [${modul}] ${pesan}`)

    try {
        await prisma.logSistem.create({
            data: {
                level,
                modul,
                pesan,
                stackTrace,
            },
        })
    } catch (error) {
        console.error(`[KEU-LOG] [CRITICAL] Gagal menulis log ke database:`, error)
    }
}

```

## File: src\lib\money.ts
```typescript
export const Money = {
  /**
   * Mengkonversi nilai float ke integer (sen/cents).
   * Contoh: 10000.50 -> 1000050
   */
  fromFloat: (amount: number): number => {
    return Math.round(amount * 100);
  },

  /**
   * Mengkonversi nilai integer (sen/cents) ke float.
   * Contoh: 1000050 -> 10000.50
   */
  toFloat: (amount: number): number => {
    return amount / 100;
  },

  /**
   * Memformat nilai integer ke format Rupiah.
   * Contoh: 1000050 -> "Rp 10.000,50"
   */
  format: (amount: number): string => {
    return new Intl.NumberFormat('id-ID', {
      style: 'currency',
      currency: 'IDR',
      minimumFractionDigits: 2,
    }).format(amount / 100);
  },

  /**
   * Menjumlahkan dua nilai integer.
   */
  add: (a: number, b: number): number => {
    return a + b;
  },

  /**
   * Mengurangkan dua nilai integer.
   */
  subtract: (a: number, b: number): number => {
    return a - b;
  },
  
  /**
   * Mengalikan nilai integer dengan faktor (misal: bunga).
   * Hasil dibulatkan ke integer terdekat.
   */
  multiply: (amount: number, factor: number): number => {
    return Math.round(amount * factor);
  }
};

```

## File: src\lib\prisma.ts
```typescript
import { PrismaClient } from "@prisma/client"

const prismaClientSingleton = () => {
    return new PrismaClient()
}

declare global {
    var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== "production") globalThis.prisma = prisma

```

## File: src\lib\template-utils.ts
```typescript
import { formatCurrency } from "./format";

export type TierBunga = {
  min_saldo: number;
  max_saldo: number | null;
  bunga_pa: number;
};

/**
 * Menghitung tanggal tagihan berikutnya berdasarkan pola tagihan.
 */
export function calculateNextBillingDate(
  pola: string,
  tanggal?: number | null,
  fromDate: Date = new Date()
): Date {
  const result = new Date(fromDate);
  result.setHours(0, 0, 0, 0);

  if (pola === "TANGGAL_TETAP") {
    if (!tanggal) return result;
    result.setDate(tanggal);
    // Jika tanggal sudah lewat di bulan ini, pindah ke bulan depan
    if (result < fromDate) {
      result.setMonth(result.getMonth() + 1);
    }
  } else if (pola === "JUMAT_MINGGU_KETIGA") {
    // Cari tanggal 1 bulan ini
    const firstDay = new Date(result.getFullYear(), result.getMonth(), 1);
    // Cari Jumat pertama
    let fridayCount = 0;
    const currentDay = firstDay;
    while (fridayCount < 1) {
      if (currentDay.getDay() === 5) { // 5 = Jumat
        fridayCount++;
      } else {
        currentDay.setDate(currentDay.getDate() + 1);
      }
    }
    // Jumat ketiga = Jumat pertama + 14 hari
    const thirdFriday = new Date(currentDay);
    thirdFriday.setDate(thirdFriday.getDate() + 14);
    
    // Jika Jumat ketiga bulan ini sudah lewat, hitung untuk bulan depan
    if (thirdFriday < fromDate) {
      const nextMonthFirstDay = new Date(result.getFullYear(), result.getMonth() + 1, 1);
      let nextFridayCount = 0;
      const nextCurrentDay = nextMonthFirstDay;
      while (nextFridayCount < 1) {
        if (nextCurrentDay.getDay() === 5) {
          nextFridayCount++;
        } else {
          nextCurrentDay.setDate(nextCurrentDay.getDate() + 1);
        }
      }
      const nextThirdFriday = new Date(nextCurrentDay);
      nextThirdFriday.setDate(nextThirdFriday.getDate() + 14);
      return nextThirdFriday;
    }
    return thirdFriday;
  } else if (pola === "HARI_KERJA_TERAKHIR") {
    // Cari hari terakhir bulan ini
    const lastDay = new Date(result.getFullYear(), result.getMonth() + 1, 0);
    // Jika weekend, mundur ke Jumat
    if (lastDay.getDay() === 0) { // Minggu
      lastDay.setDate(lastDay.getDate() - 2);
    } else if (lastDay.getDay() === 6) { // Sabtu
      lastDay.setDate(lastDay.getDate() - 1);
    }

    if (lastDay < fromDate) {
      const nextMonthLastDay = new Date(result.getFullYear(), result.getMonth() + 2, 0);
      if (nextMonthLastDay.getDay() === 0) {
        nextMonthLastDay.setDate(nextMonthLastDay.getDate() - 2);
      } else if (nextMonthLastDay.getDay() === 6) {
        nextMonthLastDay.setDate(nextMonthLastDay.getDate() - 1);
      }
      return nextMonthLastDay;
    }
    return lastDay;
  }

  return result;
}

/**
 * Mencari bunga p.a. yang berlaku berdasarkan saldo dan tier bunga.
 */
export function getApplicableInterestRate(saldo: number, tiers: TierBunga[]): number {
  if (!tiers || tiers.length === 0) return 0;
  
  const applicableTier = tiers.find(tier => {
    const minMatch = saldo >= tier.min_saldo;
    const maxMatch = tier.max_saldo === null || saldo <= tier.max_saldo;
    return minMatch && maxMatch;
  });

  return applicableTier ? applicableTier.bunga_pa : 0;
}

/**
 * Memformat informasi template ke dalam string deskriptif.
 */
export function formatTemplateInfo(template: {
  nama: string;
  biayaAdmin: number | null;
  polaTagihan: string;
  tanggalTagihan?: number | null;
}): string {
  let billingInfo = "";
  if (template.polaTagihan === "TANGGAL_TETAP") {
    billingInfo = `setiap tanggal ${template.tanggalTagihan}`;
  } else if (template.polaTagihan === "JUMAT_MINGGU_KETIGA") {
    billingInfo = "setiap Jumat minggu ketiga";
  } else if (template.polaTagihan === "HARI_KERJA_TERAKHIR") {
    billingInfo = "setiap hari kerja terakhir";
  }

  const adminFeeInfo = template.biayaAdmin 
    ? `${formatCurrency(template.biayaAdmin)} per bulan` 
    : "Tanpa biaya admin";

  return `${template.nama}: ${adminFeeInfo}, ditagih ${billingInfo}.`;
}

```

## File: src\lib\utils.ts
```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

## File: src\lib\validation.ts
```typescript
// Form validation utilities untuk real-time validation

export interface ValidationRule {
    validate: (value: any) => boolean
    message: string
}

export interface FieldValidation {
    [key: string]: ValidationRule[]
}

// Validasi wajib diisi
export const required = (message = "Wajib diisi"): ValidationRule => ({
    validate: (value) => {
        if (typeof value === "string") return value.trim().length > 0
        if (typeof value === "number") return !isNaN(value)
        return value !== null && value !== undefined
    },
    message,
})

// Validasi minimal karakter
export const minLength = (min: number, message?: string): ValidationRule => ({
    validate: (value) => typeof value === "string" && value.trim().length >= min,
    message: message || `Minimal ${min} karakter`,
})

// Validasi maksimal karakter
export const maxLength = (max: number, message?: string): ValidationRule => ({
    validate: (value) => typeof value === "string" && value.length <= max,
    message: message || `Maksimal ${max} karakter`,
})

// Validasi angka positif
export const positiveNumber = (message = "Harus angka positif"): ValidationRule => ({
    validate: (value) => {
        const num = typeof value === "string" ? parseFloat(value) : value
        return !isNaN(num) && num > 0
    },
    message,
})

// Validasi minimal angka
export const minValue = (min: number, message?: string): ValidationRule => ({
    validate: (value) => {
        const num = typeof value === "string" ? parseFloat(value) : value
        return !isNaN(num) && num >= min
    },
    message: message || `Minimal ${min.toLocaleString("id-ID")}`,
})

// Validasi maksimal angka
export const maxValue = (max: number, message?: string): ValidationRule => ({
    validate: (value) => {
        const num = typeof value === "string" ? parseFloat(value) : value
        return !isNaN(num) && num <= max
    },
    message: message || `Maksimal ${max.toLocaleString("id-ID")}`,
})

// Validasi email
export const email = (message = "Email tidak valid"): ValidationRule => ({
    validate: (value) => {
        if (!value) return true // Allow empty (use required for mandatory)
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        return emailRegex.test(value)
    },
    message,
})

// Validasi pilihan dari list
export const oneOf = (options: string[], message = "Pilihan tidak valid"): ValidationRule => ({
    validate: (value) => options.includes(value),
    message,
})

// Validasi tanggal tidak di masa lalu
export const futureDate = (message = "Tanggal harus di masa depan"): ValidationRule => ({
    validate: (value) => {
        if (!value) return true
        const date = new Date(value)
        const today = new Date()
        today.setHours(0, 0, 0, 0)
        return date >= today
    },
    message,
})

// Validasi tanggal tidak di masa depan
export const pastDate = (message = "Tanggal harus di masa lalu"): ValidationRule => ({
    validate: (value) => {
        if (!value) return true
        const date = new Date(value)
        const today = new Date()
        today.setHours(23, 59, 59, 999)
        return date <= today
    },
    message,
})

// Helper function untuk validasi satu field
export function validateField(value: any, rules: ValidationRule[]): string | null {
    for (const rule of rules) {
        if (!rule.validate(value)) {
            return rule.message
        }
    }
    return null
}

// Helper function untuk validasi semua fields
export function validateForm(
    values: Record<string, any>,
    validation: FieldValidation
): Record<string, string> {
    const errors: Record<string, string> = {}

    for (const [field, rules] of Object.entries(validation)) {
        const error = validateField(values[field], rules)
        if (error) {
            errors[field] = error
        }
    }

    return errors
}

// Check apakah form valid
export function isFormValid(errors: Record<string, string>): boolean {
    return Object.keys(errors).length === 0
}

```

## File: src\lib\validations\transaksi.ts
```typescript
import { z } from "zod"

export const TransaksiSchema = z.object({
    nominal: z.coerce.number()
        .min(100, "Nominal minimal Rp 100")
        .max(1_000_000_000, "Nominal maksimal Rp 1 miliar"),
    
    kategori: z.string()
        .min(1, "Kategori wajib diisi")
        .max(50, "Kategori maksimal 50 karakter"),
    
    deskripsi: z.string()
        .max(200, "Deskripsi maksimal 200 karakter")
        .optional(), // Deskripsi optional di beberapa form
    
    tanggal: z.coerce.date()
        .max(new Date(new Date().setHours(23, 59, 59, 999)), "Tanggal tidak boleh lebih dari hari ini"),
    
    akunId: z.string().cuid("ID akun tidak valid").optional(),
    debitAkunId: z.string().cuid().optional(),
    kreditAkunId: z.string().cuid().optional(),
    catatan: z.string().optional(),
})

export type TransaksiFormData = z.infer<typeof TransaksiSchema>

```